

<!DOCTYPE html>
<html lang="" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/Blog/img/favicon.ico">
  <link rel="icon" href="/Blog/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Daolin">
  <meta name="keywords" content="">
  
    <meta name="description" content="计算机底层">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机底层">
<meta property="og:url" content="https://daolinzhou.github.io/Blog/2020/09/08/Computing-System/">
<meta property="og:site_name" content="Daolin&#39;s Repository">
<meta property="og:description" content="计算机底层">
<meta property="og:locale">
<meta property="og:image" content="https://daolinzhou.github.io/Blog/intro/comp_sys/data_p.PNG">
<meta property="article:published_time" content="2020-09-08T18:49:11.000Z">
<meta property="article:modified_time" content="2021-04-14T07:27:28.327Z">
<meta property="article:author" content="Daolin">
<meta property="article:tag" content="汇编">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://daolinzhou.github.io/Blog/intro/comp_sys/data_p.PNG">
  
  
  <title>计算机底层 - Daolin&#39;s Repository</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/Blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"daolinzhou.github.io","root":"/Blog/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/Blog/local-search.xml"};
  </script>
  <script  src="/Blog/js/utils.js" ></script>
  <script  src="/Blog/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/Blog/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/">
                <i class="iconfont icon-home-fill"></i>
                Hejmpaĝo
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Arkivoj
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                Kategorioj
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Etikedoj
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Blog/about/">
                <i class="iconfont icon-user-fill"></i>
                Pri
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/Blog/intro/Deemo.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="计算机底层">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-08 11:49" pubdate>
        September 8, 2020 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      64k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      531 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">计算机底层</h1>
            
            <div class="markdown-body">
              <h1 id="计算机底层"><a href="#计算机底层" class="headerlink" title="计算机底层"></a>计算机底层</h1><span id="more"></span>
<h2 id="内存和数据"><a href="#内存和数据" class="headerlink" title="内存和数据"></a>内存和数据</h2><p>由于现实中内存有限, 所以所有数据都以”固定”长度存储</p>
<ul>
<li>Data is moved and manipulated in fixed-length chunks</li>
<li>Multiple fixed lengths (e.g. 1 bytes, 4 bytes, 8 bytes)</li>
<li>Leading zeros now must be included up to “fill out” the fixed length</li>
</ul>
<p>例如: the “eight-bit” representation of the number 4 is 0b00000100</p>
<p>最左边的 bit 叫做 most significant bit(MSB). 4 Bytes System 中在第32位, 8 Bytes System 中在第64位</p>
<p>最右边的 bit 叫做 least significant bit (LSB).</p>
<p><br></p>
<h3 id="Machine-“Words”"><a href="#Machine-“Words”" class="headerlink" title="Machine “Words”"></a>Machine “Words”</h3><p>当你有一组存储在一起的bytes, 我们可以称之为Words</p>
<p>We have choosen to tie word size to address size/width</p>
<ul>
<li>word size = address size = register size</li>
<li>word size = w bits -&gt; $2^w$ addresses</li>
</ul>
<p><br></p>
<p>当前 x86 系统 使用64-bit(8-byte) words</p>
<ul>
<li>Potential address space: $2^{64}$ addresses</li>
<li>Actual physical address space: 48 bits</li>
</ul>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/word.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Addresses still specify location of bytes in memory</p>
<p>Addresses of successive words differ by word size(in bytes)</p>
<p>Address word = address of <strong>first byte</strong> in word</p>
<p><strong>The address of any chunk of memory is given by the address of the first byte</strong></p>
<p><img src="/Blog/intro/comp_sys/data_p.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>注意在c中要使用 bool 必须 include stdbool.h</p>
</blockquote>
<p><br></p>
<h3 id="对齐-Alignment"><a href="#对齐-Alignment" class="headerlink" title="对齐 Alignment"></a>对齐 Alignment</h3><p><br></p>
<p>Primitive object of K bytes must have an address that is a multiple of K</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">K</th>
<th style="text-align:center">Type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">char</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">short</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">int, float</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">long, double, pointers</td>
</tr>
</tbody>
</table>
</div>
<p>例如:</p>
<p>int的地址必须是以00结尾, 因为int型的地址必须是4的倍数, 4在二进制是100, 所以地址必须以00结尾</p>
<p>同理short的地址必须以0结尾</p>
<p>long, double, pointer的地址要以000结尾</p>
<p>char 可以以0, 或1结尾</p>
<p><br></p>
<h3 id="大端存储与小端存储"><a href="#大端存储与小端存储" class="headerlink" title="大端存储与小端存储"></a>大端存储与小端存储</h3><p>字节在一个Word中是怎么存储的?</p>
<p>例如存储一个4-byte(32-bit) int</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">0</span>x <span class="hljs-built_in">a1</span> b2 <span class="hljs-built_in">c3</span> <span class="hljs-built_in">d4</span><br></code></pre></td></tr></table></figure>
<p><br></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>地址</th>
<th>Big</th>
<th>little</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0</td>
<td>a1</td>
<td>d4</td>
</tr>
<tr>
<td>0x1</td>
<td>b2</td>
<td>c3</td>
</tr>
<tr>
<td>0x2</td>
<td>c3</td>
<td>b2</td>
</tr>
<tr>
<td>0x3</td>
<td>d4</td>
<td>a1</td>
</tr>
</tbody>
</table>
</div>
<p>big-endian System: the most significant bit (MSB) goes to the least address. a1 存在0x0中 </p>
<p>little-endian System: the Least significant bit (LSB) goes to the least address. d4 存在0x0中</p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/data_p_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Endianness only applies to memory storage</p>
<p><br></p>
<p><br></p>
<h3 id="C-内存分布"><a href="#C-内存分布" class="headerlink" title="C 内存分布"></a>C 内存分布</h3><p><img src="/Blog/intro/comp_sys/memory.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>程序的 <strong>address space</strong> 包含4个部分</p>
<ul>
<li>Stack: 栈, 存储 local variable, 向下增长</li>
<li>Heap: 堆, c语言使用malloc函数, c++, java中new, 使用pointer进行访问, 会自动 resize, 向上增长</li>
<li>Static Data: global and static variables. 不会增长</li>
<li>Code: loaded when program starts, does not change</li>
</ul>
<p><br></p>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p><img src="/Blog/intro/comp_sys/stack_frame.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>每个stack frame都是一个连续的内存块, 包含 the local variables of a single procedure</p>
<p>一个stack frame包含:</p>
<ul>
<li>Location of caller function</li>
<li>Function arguments</li>
<li>space for local variables</li>
</ul>
<p>Stack Pointer (SP) 告诉我们 lowest (current) stack frame 在哪.</p>
<p>当函数调用结束, stack pointer会移回上一个位置. (但数据不会清除)</p>
<p><br></p>
<h4 id="Static-Data"><a href="#Static-Data" class="headerlink" title="Static Data"></a>Static Data</h4><p>String 和 global varibals 会存在这里,</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">char* str <span class="hljs-operator">=</span> <span class="hljs-string">&quot;h1&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<p>size does not change, but sometimes data can</p>
<p>Notably string literals cannot</p>
<p><br></p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>copy of your code goes here</p>
<p>C code becomes data too. </p>
<p>Does not change.</p>
<p><br></p>
<p><br></p>
<h2 id="位运算-MASK"><a href="#位运算-MASK" class="headerlink" title="位运算, MASK"></a>位运算, MASK</h2><p><img src="/Blog/intro/comp_sys/poker.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>假设我们要使用一种方式来表示扑克.</p>
<p>52张卡. 4个种类.</p>
<p>我们期望这种表示方式能进行如下操作:</p>
<ol>
<li>比较两张卡上的数.</li>
<li>判断他们是否在同一类别 (红桃, 黑桃,方片, 梅花)</li>
</ol>
<p><br></p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/bit_op.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">~(<span class="hljs-keyword">A</span> | B) = ~<span class="hljs-keyword">A</span> &amp; ~B<br>~(<span class="hljs-keyword">A</span> &amp; B) = ~<span class="hljs-keyword">A</span> | ~B<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>位运算符和逻辑算符不一样.</p>
<p>对于逻辑运算符来说, 0代表False, 非零代表True</p>
<p>逻辑运算符 &amp;&amp;, ||, ! 总是会返回0或1.</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">!<span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x41</span>  -&gt;</span> <span class="hljs-number">0</span>x00<br>!<span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x00</span>  -&gt;</span> <span class="hljs-number">0</span>x01<br>!!<span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x41</span> -&gt;</span> <span class="hljs-number">0</span>x01<br><span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">xCC</span> &amp;&amp; 0x33 -&gt;</span> <span class="hljs-number">0</span>x01<br><span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x00</span> &amp;&amp; 0x33 -&gt;</span> <span class="hljs-number">0</span>x01<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>使用独热码(One Hot encoding)</p>
<p>回到问题中, 第一种方式就是使用独热码.</p>
<p><img src="/Blog/intro/comp_sys/one_hot.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>一位代表一个卡片. 52位就可以代表52张卡</p>
<p>缺点: </p>
<ul>
<li><p>难以比较大小和类别</p>
</li>
<li><p>需要大量bit位</p>
</li>
</ul>
<p><br></p>
<h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>让最后的13位代表值, 再用倒数14-17位代表种类</p>
<p><img src="/Blog/intro/comp_sys/one_hot_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>相当于用两部分的独热码组成. 4位的独热码代表种类, 13位的独热码代表值</p>
<p>这样既可以比较大小又可以比较类别.</p>
<p>缺点是依然需要大量的bit来存储, 总共需要17位, 所以要申请32位的bits</p>
<p><br></p>
<h3 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h3><p>对第一种方法进行压缩.</p>
<p>$2^6=64&gt;52$. 所以可以用6位代表所有卡牌</p>
<p><img src="/Blog/intro/comp_sys/one_hot_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>然而它和第一种方法一样, 难以比较大小和类别</p>
<p><br></p>
<h3 id="第四种方法"><a href="#第四种方法" class="headerlink" title="第四种方法"></a>第四种方法</h3><p>对第二种方法进行压缩.</p>
<p>2bit可以表示4种状态.</p>
<p><img src="/Blog/intro/comp_sys/one_hot_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>$2^4 = 16 &gt; 13$. 4位代表值</p>
<p>依然使用6 bits, 使用 1byte 就可以存储(char)</p>
<p><img src="/Blog/intro/comp_sys/one_hot_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="对比两张卡的种类是否一致"><a href="#对比两张卡的种类是否一致" class="headerlink" title="对比两张卡的种类是否一致"></a>对比两张卡的种类是否一致</h3><p>我们使用第四种方式进行存储, 因为这种方式最好.</p>
<p>假设我们有两张卡, 如何设计一个函数isSameSuit判断两张卡的种类是否一致?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SUIT_MASK 0x30</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">isSameSuit</span><span class="hljs-params">(<span class="hljs-type">char</span> card1, <span class="hljs-type">char</span> card2)</span>&#123;<br>    <span class="hljs-keyword">return</span> (card1 &amp; SUIT_MASK) == (card2 &amp; SUIT_MASK);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们定义SUIT_MASK</p>
<p><img src="/Blog/intro/comp_sys/mask.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>mask: a bit vector designed to achieve a desired behavior when used with a bitwise operator on another bit vector v.</p>
<p><br></p>
<p>如果我们让一个 number 位与(&amp;) mask. 我们就得到了mask中我们关心的位的状态.</p>
<p>例如上面的例子中, 5, 6位代表的是卡片种类. 所以用 card &amp; mask, 就把5, 6位以外的值过<strong>滤掉</strong>了. 使得我们可以专注于比较5, 6两位.</p>
<p><img src="/Blog/intro/comp_sys/mask_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>或者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SUIT_MASK 0x30</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">isSameSuit</span><span class="hljs-params">(<span class="hljs-type">char</span> card1, <span class="hljs-type">char</span> card2)</span>&#123;<br>    <span class="hljs-keyword">return</span> !((card1 &amp; SUIT_MASK) ^ (card2 &amp; SUIT_MASK));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>依然使用mask过滤其余信息. 不过判断等于时使用XOR. 如果<strong>两个值相等XOR的结果就是0, 反之非零</strong>. 对XOR的结果取反(自动转bool)就是我们希望的答案.</p>
<p><br></p>
<p><br></p>
<h3 id="对比数值"><a href="#对比数值" class="headerlink" title="对比数值"></a>对比数值</h3><p>对于卡片我们还要比较他们的大小 greaterValue</p>
<p>有了上面的经验, 这个函数就好写了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> VALUE_MASK 0x0f</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">greaterValue</span><span class="hljs-params">(<span class="hljs-type">char</span> card1, <span class="hljs-type">char</span> card2)</span>&#123;<br>	<span class="hljs-keyword">return</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(card1 &amp; VALUE_MASK) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(card2 &amp; VALUE_MASK));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同样使用一个MASK. </p>
<p><img src="/Blog/intro/comp_sys/mask_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Two’s-Complement-Arithmetic"><a href="#Two’s-Complement-Arithmetic" class="headerlink" title="Two’s Complement Arithmetic"></a>Two’s Complement Arithmetic</h2><p>加法操作同时作用于unsigned and two’s complement integers.</p>
<ul>
<li><strong>Simplifies hardware</strong>: only one algorithm for addition</li>
<li><strong>Algorithm</strong>: simple addition, <strong>discard the highest carry bit</strong><ul>
<li>Called modular addition: result is sum modulo $2^w$</li>
</ul>
</li>
</ul>
<p><img src="/Blog/intro/comp_sys/two_comp.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="为什么这个东西起作用"><a href="#为什么这个东西起作用" class="headerlink" title="为什么这个东西起作用?"></a>为什么这个东西起作用?</h3><p>首先我们希望所有integer x</p>
<p><img src="/Blog/intro/comp_sys/two_comp_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>如果我们让 x+~x会得到什么结果?</p>
<p><img src="/Blog/intro/comp_sys/two_comp_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>那么如果用 x+~x + 1 得到的就是0.</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">x</span> + (-<span class="hljs-keyword">x</span>) <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">x</span> + (~<span class="hljs-keyword">x</span>) + <span class="hljs-number">1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>因此 -x 就是 ~x+1</p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/two_comp_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="In-C-Signed-vs-Unsigned"><a href="#In-C-Signed-vs-Unsigned" class="headerlink" title="In C, Signed vs. Unsigned"></a>In C, Signed vs. Unsigned</h3><p><img src="/Blog/intro/comp_sys/casting.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>可以使用后缀U或u来表示unsigned</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0U</span>, <span class="hljs-number">234322</span>u<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>当signed 和unsigned比较时 <strong>signed value</strong> 会隐式转化成 <strong>unsigned value</strong></p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;, &gt;</span>, ==, <span class="hljs-attribute">&lt;=, &gt;</span>=<br></code></pre></td></tr></table></figure>
<p><br></p>
<h2 id="Sign-Extension"><a href="#Sign-Extension" class="headerlink" title="Sign Extension"></a>Sign Extension</h2><p>如果我们把一个signed integer转换成一个更大的数据类型?</p>
<p>char -&gt; short -&gt; int -&gt; long</p>
<p>4bits 转8bits的例子:</p>
<p><img src="/Blog/intro/comp_sys/casting_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>然而如果是复数会怎么办?</p>
<p><br></p>
<p>这个过程被称为Sign Extension</p>
<p><img src="/Blog/intro/comp_sys/casting_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>假设转化的类型比原来的大k个bits. 这k个bits会填充为signed integer的signed值.</p>
<p><img src="/Blog/intro/comp_sys/casting_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h2 id="Shift-位移运算"><a href="#Shift-位移运算" class="headerlink" title="Shift 位移运算"></a>Shift 位移运算</h2><p>位移运算 shift : x&lt;&lt;n</p>
<p>Shifts by n<0 or n>=w (bit width of x) are <strong>undefined</strong></p>
<p><img src="/Blog/intro/comp_sys/shift.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Arithmetic-Shift"><a href="#Arithmetic-Shift" class="headerlink" title="Arithmetic Shift"></a>Arithmetic Shift</h3><p>对于signed number来说</p>
<p>左移补0, 右移补sign, sign是0就补0, 是1就补1.</p>
<p><br></p>
<h3 id="Logical-Shift"><a href="#Logical-Shift" class="headerlink" title="Logical Shift"></a>Logical Shift</h3><p>对于 unsigned number来说</p>
<p>左移和右移都补0</p>
<p><br></p>
<blockquote>
<p>C 语言中, &gt;&gt; 使用那种shift取决于编译器, 换句话说取决于x是unsigned还是signed</p>
<p>java中 logical shift 是 &gt;&gt;&gt;, arithmetic shift 是 &gt;&gt;</p>
</blockquote>
<p><br></p>
<p>假设我们对一个数进行位移</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span> = <span class="hljs-number">25</span>;    <span class="hljs-number">0001</span> <span class="hljs-number">1001</span> = <span class="hljs-number">25</span><br><span class="hljs-attribute">x</span> &lt;&lt; <span class="hljs-number">2</span>;    <span class="hljs-number">0110</span> <span class="hljs-number">0100</span> = <span class="hljs-number">100</span><br><span class="hljs-attribute">x</span> &lt;&lt; <span class="hljs-number">3</span>;    <span class="hljs-number">1100</span> <span class="hljs-number">1000</span> = -<span class="hljs-number">56</span><br></code></pre></td></tr></table></figure>
<p>左移一位相当于乘以2. 但可能会overflow</p>
<p><br></p>
<p>那么右移一位是否相当于除以2呢</p>
<p>如果是符号位是0或者无符号位的话肯定是的.</p>
<p>如果是有符号位呢?</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span> = -<span class="hljs-number">16</span>;    <span class="hljs-number">1111</span> <span class="hljs-number">0000</span> = -<span class="hljs-number">16</span><br><span class="hljs-attribute">x</span> &gt;&gt; <span class="hljs-number">3</span>;     <span class="hljs-number">1111</span> <span class="hljs-number">1110</span> = -<span class="hljs-number">2</span><br><span class="hljs-attribute">x</span> &gt;&gt; <span class="hljs-number">5</span>;     <span class="hljs-number">1111</span> <span class="hljs-number">1111</span> = -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>相当于 $\frac {-16} {2^3} = -2$</p>
<p>-16 除以 2 的 n次方结果应该也是一个负数, 这也是为什么右移会补1.</p>
<p><br></p>
<p><br></p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>有3种基础的指令:</p>
<ol>
<li>Transfor data between memory and register<ul>
<li><strong>Load</strong> data from memory into register</li>
<li><strong>Store</strong> register data in to memory</li>
</ul>
</li>
<li>Perform arithmetic operation on register or memory data<ul>
<li>c = a + b;    z = x &lt;&lt; y;    i = h &amp; g</li>
</ul>
</li>
<li>Control flow: what instruction to execute next<ul>
<li>Unconditional jumps to/from procedures</li>
<li>Conditional branches</li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="Operand-Types"><a href="#Operand-Types" class="headerlink" title="Operand Types"></a>Operand Types</h3><ul>
<li>Immediate: 常数<ul>
<li>例如: $0x400, $-533</li>
<li>需要前缀 $</li>
<li>encoded with 1, 2, 4 or 8 bytes, <strong>depending on the instruction</strong></li>
</ul>
</li>
<li>Register: 22 integer registers<ul>
<li>例如: %x9 ,,, %31</li>
<li>但是 %x0-x4 and %x8 有特殊用途被保留</li>
<li>Others have special uses for particular instructions</li>
</ul>
</li>
<li>Memory: Consecutive bytes of memory at a computed address<ul>
<li>%x18</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="Zero-register"><a href="#Zero-register" class="headerlink" title="Zero register"></a>Zero register</h3><p>0 经常出现在代码中. 所以它有自己的寄存器</p>
<p>Register zero (<strong>x0</strong> or <strong>zero</strong>) 的值一直是0且不会被改变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">add s3, x0, x0	# c=0<br>add s1, s2, x0  # a=b<br></code></pre></td></tr></table></figure>
<p>使用寄存器代表 zero 与使用常数 0 有什么不同?</p>
<p>以 下面语句为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add s3, x0, x0	# c=0<br></code></pre></td></tr></table></figure>
<p>x0 会自动映射为 0(硬件层面上), 在编译器层面, 它只是执行这一条指令</p>
<p>使用add指令作用在两个寄存器上, 将x0和x0的和存储在s3中</p>
<p>或者下面语句也同样可以达到效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">addi s3, x0, 0<br></code></pre></td></tr></table></figure>
<p>addi 是 add immediate 的缩写. 此时x0是寄存器, 0是常数</p>
<p><br></p>
<h3 id="Immediates"><a href="#Immediates" class="headerlink" title="Immediates"></a>Immediates</h3><p>Numreical Constants 被叫做 <strong>immediates</strong></p>
<p>Separate instruction syntax for immediates:</p>
<p>语法: 指令, 目标寄存器, 原寄存器, 常数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">opi,  dst,  src,  imm<br># 会把imm和src中存储的值进行opi运算后的结果放入dst中<br></code></pre></td></tr></table></figure>
<p>operation names end with ‘i’, replace 2nd source register with an immediate</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">addi s1, s2, 5    # a=b+5<br>addi s3, s3, 1    # c++<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>寄存器和寄存器之间有add, 和 sub.</p>
<p>为什么寄存器和常数之间只有 addi</p>
<p>因为编译器要限制operations的种类个数为最低</p>
<ul>
<li>if an operation can be decomposed into a simpler operation, don’t include it</li>
<li>减去一个常数可以替换为加将负的这个常数</li>
</ul>
<p><br></p>
<h2 id="Memory-Address-are-in-Bytes"><a href="#Memory-Address-are-in-Bytes" class="headerlink" title="Memory Address are in Bytes"></a>Memory Address are in Bytes</h2><p>Data通常有小于32bits但很少有小于8bits的 (char类型)</p>
<p>一个 8 bit chunk 叫作 byte (1 word = 4 bytes)</p>
<p>memory address are really in bytes, not words</p>
<p>Word Address are 4 bytes apart</p>
<ul>
<li>word address is same as address of rightmost byte - least - significant byte(例如 Little-endian convention)</li>
</ul>
<p><br></p>
<h2 id="Registers"><a href="#Registers" class="headerlink" title="Registers"></a>Registers</h2><p>RISC-V总共有32个寄存器. 每个寄存器32bits 宽</p>
<p>每个寄存器有两个名字</p>
<p><img src="/Blog/intro/comp_sys/register.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/register_1.png" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>regisiters 最大为8Byte, B代表Byte</p>
</blockquote>
<p><br></p>
<p>和高级语言(c,java…)不同, <strong>寄存器没有类型</strong></p>
<p>Operation determines how register contents are treated.</p>
<p><br></p>
<p>Instruction Syntax is rigid:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">op  dst,  src1,  src2<br></code></pre></td></tr></table></figure>
<p>1 operator, 3 operands</p>
<ul>
<li>op = operation name(“operator”)</li>
<li>dst = register getting result (“destination”)</li>
<li>src1 = first register for operation (“source 1”)</li>
<li>src2 = second register for operation (“source 2”)</li>
</ul>
<p>One operation per instruction, at most one instruction per line</p>
<p>每条指令最多读取 2 operands, 最多写入 1 operand, can only perform one operation</p>
<p><br></p>
<h2 id="指令示例"><a href="#指令示例" class="headerlink" title="指令示例"></a>指令示例</h2><h3 id="从内存中加载数据到寄存器"><a href="#从内存中加载数据到寄存器" class="headerlink" title="从内存中加载数据到寄存器"></a>从内存中加载数据到寄存器</h3><p>c 语言</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> A[<span class="hljs-number">100</span>];<br>g = h + A[<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure>
<p>在RISC-V中使用Load Word(lw)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">lw    x10, <span class="hljs-number">12</span>(x15)	  <span class="hljs-comment"># Reg x10 gets A[3]</span><br>add   x11, x12, x10   <span class="hljs-comment"># g = h + A[3]</span><br></code></pre></td></tr></table></figure>
<p>x15指向A[0], 12是offset in bytes</p>
<p>offset must be a constant know at assembly time</p>
<p>但是我们通常会见到A[index]这种写法. index显然不是constant. 那它是怎么做的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># int sumofarray(int a[], int i) &#123;<br>#     return a[i];<br># &#125;<br><br>slli a1, a1, 2	  # i &lt;&lt; 2, i = i*4<br>add a0, a0, a1    # a = a + i<br>lw a0, 0(a0)      # return a[0]<br>ret<br></code></pre></td></tr></table></figure>
<p>此时offset就是0, 我们通过加法进行偏移后进行写入.</p>
<p><br></p>
<h3 id="把寄存器中的数据写入内存"><a href="#把寄存器中的数据写入内存" class="headerlink" title="把寄存器中的数据写入内存"></a>把寄存器中的数据写入内存</h3><p>c 语言</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> A[<span class="hljs-number">100</span>];<br>A[<span class="hljs-number">10</span>] = h + A[<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure>
<p>在RISC-V中使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lw    x10, 12(x15)    # Temp reg x10 gets A[3]<br>add   x10, x12, x10   # Temp reg x10 gets h+A[3]<br>sw    x10, 40(x15)    # A[10] = h + A[3]<br></code></pre></td></tr></table></figure>
<p><br></p>
<h3 id="Loading-and-Storing-Bytes"><a href="#Loading-and-Storing-Bytes" class="headerlink" title="Loading and Storing Bytes"></a>Loading and Storing Bytes</h3><p>lw, sw 分别是 load word, save word</p>
<p>RISC-V还可以对byte进行操作</p>
<ul>
<li>load byte: lb</li>
<li>save byte: sb</li>
</ul>
<p>和 lw, sw 的使用方式一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lb x10, 3(x11)<br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/comp_sys/lbsb.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>lb只读取一个byte, 存入x10, x10是一个word size(4byte)</p>
<p>因此读取的1byte数据存在x10的最后一个byte中(<strong>low byte position</strong> of register x10)</p>
<p>之后前面的位用sign-extend补齐.</p>
<blockquote>
<p>RISC-V同样还有 “unsigned byte” loads(lbu) which <strong>zero extends</strong> to fill register.</p>
</blockquote>
<p><br></p>
<p><br></p>
<h3 id="Integer-Addition-add"><a href="#Integer-Addition-add" class="headerlink" title="Integer Addition (add)"></a>Integer Addition (add)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add s1, s2, s3        # a = b + c<br></code></pre></td></tr></table></figure>
<p>3 operands, 读取s1, s2, 写入s3.</p>
<p>每条指令最多读取 2 operands, 最多写入 1 operand, can only perform one operation</p>
<p><br></p>
<h3 id="Integer-Subtraction-sub"><a href="#Integer-Subtraction-sub" class="headerlink" title="Integer Subtraction (sub)"></a>Integer Subtraction (sub)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">sub s1, s2, s3        # a = b - c, s3-s2<br></code></pre></td></tr></table></figure>
<p><br></p>
<p>假设 a-&gt;s0, b-&gt;s1, c-&gt;s2, d-&gt;s3, e-&gt;s4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># a = (b + c) - (d + e)<br>add t1, s1, s2<br>add t2, s3, s4<br>sub s0, t2, t1<br></code></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h3 id="Branch-if-equal"><a href="#Branch-if-equal" class="headerlink" title="Branch if equal"></a>Branch if equal</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">beq  reg1, reg2, label<br></code></pre></td></tr></table></figure>
<p>如果 reg1 内存储的值等于 reg2 内存储的值, 则跳转到 label</p>
<p><img src="/Blog/intro/comp_sys/beq.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Branch-if-Not-equal"><a href="#Branch-if-Not-equal" class="headerlink" title="Branch if Not equal"></a>Branch if Not equal</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">bne  reg1, reg2, label<br></code></pre></td></tr></table></figure>
<p>如果 reg1 内存储的值不等于 reg2 内存储的值, 则跳转到 label</p>
<p><img src="/Blog/intro/comp_sys/bne.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Jump"><a href="#Jump" class="headerlink" title="Jump"></a>Jump</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">j  label<br></code></pre></td></tr></table></figure>
<p>跳转到label</p>
<p><br></p>
<h3 id="Set-less-Than-slt"><a href="#Set-less-Than-slt" class="headerlink" title="Set less Than(slt)"></a>Set less Than(slt)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">slt  dst, reg1, reg2<br></code></pre></td></tr></table></figure>
<p>如果 reg1 存储的值 &lt; reg2 存储的值, dst = 1, else dst = 0</p>
<p><img src="/Blog/intro/comp_sys/slt.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Set-less-Thanimmediate-slti"><a href="#Set-less-Thanimmediate-slti" class="headerlink" title="Set less Thanimmediate(slti)"></a>Set less Thanimmediate(slti)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">slti dst, reg1, imm<br></code></pre></td></tr></table></figure>
<p>如果 reg1 存储的值 &lt; imm, dst = 1, else dst = 0</p>
<p><br></p>
<h3 id="Branch-Less-Than-blt"><a href="#Branch-Less-Than-blt" class="headerlink" title="Branch Less Than(blt)"></a>Branch Less Than(blt)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">blt reg1, reg2, label<br></code></pre></td></tr></table></figure>
<p>如果 reg1 存储的值 &lt; reg2 存储的值, 跳到label</p>
<p><br></p>
<h3 id="Branch-Greater-Than-or-Equal-bge"><a href="#Branch-Greater-Than-or-Equal-bge" class="headerlink" title="Branch  Greater Than or Equal(bge)"></a>Branch  Greater Than or Equal(bge)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">bge reg1, reg2, label<br></code></pre></td></tr></table></figure>
<p>如果 reg1 存储的值 &gt;= reg2 存储的值, 跳到label</p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/for-loop.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>0(x9) 既相当于访问A[0], 也相当于*A</p>
<p><br></p>
<h3 id="乘法-Multipication-mul-and-mulh"><a href="#乘法-Multipication-mul-and-mulh" class="headerlink" title="乘法 Multipication(mul and mulh)"></a>乘法 Multipication(mul and mulh)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mul    dst, src1, src2<br>mulh   dst, src1, src2<br></code></pre></td></tr></table></figure>
<p>src1 * src2: </p>
<ul>
<li>lower 32 bits through mul</li>
<li>upper 32 bits through mulh</li>
</ul>
<p><br></p>
<h3 id="除法-Division-div"><a href="#除法-Division-div" class="headerlink" title="除法 Division(div)"></a>除法 Division(div)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">div    dst, src1, src2<br>rem    dst, src1, src2<br></code></pre></td></tr></table></figure>
<p>src1/src2:  quotient via <strong>div</strong>, remainder via <strong>rem</strong></p>
<p>通过div求商, rem求余数</p>
<p><br></p>
<h3 id="位运算-Bitwise-Instructions"><a href="#位运算-Bitwise-Instructions" class="headerlink" title="位运算(Bitwise Instructions)"></a>位运算(Bitwise Instructions)</h3><p><img src="/Blog/intro/comp_sys/biwise_ins.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h3><p><img src="/Blog/intro/comp_sys/shift_ins.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># sample calls to shift instructions<br>addi  t0,x0 ,-256 # t0=0xFFFFFF00<br>slli  s0,t0,3     # s0=0xFFFFF800<br>srli  s1,t0,8     # s1=0x00FFFFFF<br>srai  s2,t0,8     # s2=0xFFFFFFFF<br><br>addi t1,x0 ,-22   # t1=0xFFFFFFEA<br>                  # low 5: 0b01010<br>sll s3,t0,t1      # s3=0xFFFC0000<br># same as slli s3,t0,10<br></code></pre></td></tr></table></figure>
<p>shift只看最后5位, 因为最后5位表达0-31</p>
<p><br></p>
<p><br></p>
<h2 id="Stored-Program-Concept"><a href="#Stored-Program-Concept" class="headerlink" title="Stored Program Concept"></a>Stored Program Concept</h2><p>我们如何表达一个指令?</p>
<p>计算机只知道0和1, 汇编指令 “add x10, x11, x0” 这个字符串对于硬件来说是没有意义的</p>
<p><br></p>
<p>Big idea 是 <strong>指令是数据</strong></p>
<p>程序像numbers一样可以被存储到内存中</p>
<p><br></p>
<p>RISCV 指令占用1 word = 4 bytes = 32 bits</p>
<p>而指令类似add x10, x11, x0 就会被encode到这 32 bit number中</p>
<p>首先会把32bits 分成一个个区域<strong>fields</strong></p>
<p><br></p>
<p>Every thing have a memory address</p>
<p>PC指针: One register keeps address of instruction being executed: “Program Counter” (PC)</p>
<ul>
<li><p>Basically a pointer to memory</p>
</li>
<li><p>Intel calls it Instruction Pointer (IP)</p>
</li>
</ul>
<p><br></p>
<p>Programs are distributed in binary form</p>
<p>Programs bound to specific instruction set </p>
<p><br></p>
<p><br></p>
<h3 id="Instruction-Format"><a href="#Instruction-Format" class="headerlink" title="Instruction Format"></a>Instruction Format</h3><p>RISC-V 有6种指令格式</p>
<p><img src="/Blog/intro/comp_sys/format.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="R-Format"><a href="#R-Format" class="headerlink" title="R-Format"></a>R-Format</h3><p><img src="/Blog/intro/comp_sys/r.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>opcode 解释了一部分这个operator干什么</p>
<p>它同时也是用于区分R-format和其他Format</p>
<p><img src="/Blog/intro/comp_sys/format_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>举个例子:</p>
<p><img src="/Blog/intro/comp_sys/format_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>所有 R-Format 的 指令</p>
<p><img src="/Blog/intro/comp_sys/format_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>Add 和 Sub 的func3 一样, SRL (logical right shift)和SRA(Arithmetic right shift)的func3一样. 需要用func7区分</p>
</blockquote>
<p><br></p>
<p><br></p>
<h3 id="I-Format"><a href="#I-Format" class="headerlink" title="I-Format"></a>I-Format</h3><p>5-bit field too small for most immediates. (常数)</p>
<p>RISCV 只有一种指令格式(为了简单起见), 然而在这里我们不得不做出让步</p>
<p>我们要为immediate设计一个新的格式</p>
<p>如果一条指令包含immediate, 那么它最多使用2个寄存器, 一个source, 一个destination.</p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/format_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>例子:</p>
<p><img src="/Blog/intro/comp_sys/format_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>I-Format指令</p>
<p><img src="/Blog/intro/comp_sys/format_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="Load-指令也是I-Format"><a href="#Load-指令也是I-Format" class="headerlink" title="Load 指令也是I-Format"></a>Load 指令也是I-Format</h4><p><img src="/Blog/intro/comp_sys/format_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>所有的load指令</p>
<p><img src="/Blog/intro/comp_sys/format_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>没有Load unsigned word 是因为load word没有 sign extension 的必要, 然而load half word 和 load byte 都需要将数据放入word(寄存器)中, 需要sign/zero extension</p>
<p><br></p>
<h3 id="S-Format"><a href="#S-Format" class="headerlink" title="S-Format"></a>S-Format</h3><p>Store 需要两个寄存器, res1是base memory address. res2时要被存储的数据. 同时还要有一个immediate offset.</p>
<p>store 不需要 rd, 目标寄存器, 而RISC-V为了让rs1, 和rs2保持在原来的位置, 所以它把immediate的low5位放到原本load指令的rd的位置</p>
<p><img src="/Blog/intro/comp_sys/format_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>imm被拆成两部分, imm[4:0]占据了原本rd的位置</p>
<p>res1和res2保持在原本的位置不动</p>
<p>举个例子:</p>
<p><img src="/Blog/intro/comp_sys/format_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="SB-Format"><a href="#SB-Format" class="headerlink" title="SB-Format"></a>SB-Format</h3><p>beq, bne, bge, blt</p>
<p>需要指定一个跳转的地址</p>
<p>同时需要有<strong>两个</strong>用于比较的寄存器</p>
<blockquote>
<p>回顾: 指令存储在内存中</p>
<p>Largest Branch distance limited by size of code</p>
<p>Address of current instruction stored in the program counter (PC)</p>
</blockquote>
<h4 id="PC-relative-Addressing"><a href="#PC-relative-Addressing" class="headerlink" title="PC-relative-Addressing"></a>PC-relative-Addressing</h4><p>PC 相对寻址: 使用 immediate field as a two’s complement offset to PC</p>
<ul>
<li>Branches generally change the PC by a small amount</li>
<li>Can specify $\pm 2^{11}$ addresses from the PC</li>
</ul>
<p><br></p>
<p>然而指令必须是word对齐的, 必须从4的倍数的地址读取指令, 所以我们完全可以用byte address, 这样就能更大范围寻址</p>
<p>Why not use <strong>byte address</strong> offset from PC as the immediate?</p>
<p>RISCV 用32bits addresses, and memory is byte-addressed</p>
<p>Instructions are “<strong>word-aligned</strong>“: Address is always a multiple of 4(in byte)</p>
<p>PC ALWAYS point to an instruction</p>
<p><img src="/Blog/intro/comp_sys/format_19.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_20.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<ul>
<li><p>Extensions to RISC-V base ISA support 16-bit compressed instructions and also variable-length instructions that are multiples of 16-bits in length</p>
</li>
<li><p>16-bit = half-word</p>
</li>
<li><p>To enable this, RISC-V scales the branch offset to be <strong>half-words</strong> even when there are no 16-bit instructions</p>
</li>
<li><p>Reduces branch reach by half and means that ½ of possible targets will be errors on RISC-V processors that only support 32-bit instructions (as used in this class)</p>
</li>
<li><p>RISC-V conditional branches can only reach ± 210 × 32-bit instructions either side of PC</p>
</li>
</ul>
<p><img src="/Blog/intro/comp_sys/format_21.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_22.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_23.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_24.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_30.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_31.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="U-Format"><a href="#U-Format" class="headerlink" title="U-Format"></a>U-Format</h3><p>如果我们处理的immediates是32-bit怎么办?</p>
<p>I-type instructions only gives us 12 bits.</p>
<p>因此我们需要新的指令结构来处理剩下的20bits</p>
<p>This instruction should deal with:</p>
<ul>
<li>a destination register to put the 20 bits into</li>
<li>the immediate of 20 bits</li>
<li>the instruction opcode</li>
</ul>
<p><img src="/Blog/intro/comp_sys/format_32.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="Load-Upper-Immediate-LUI"><a href="#Load-Upper-Immediate-LUI" class="headerlink" title="Load Upper Immediate(LUI)"></a>Load Upper Immediate(LUI)</h4><p><img src="/Blog/intro/comp_sys/format_33.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_34.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>因为前20位会extend 1, 相当于-1</p>
<p>因此此时我们要将它前20位</p>
<p><img src="/Blog/intro/comp_sys/format_35.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="UJ-Format"><a href="#UJ-Format" class="headerlink" title="UJ-Format"></a>UJ-Format</h3><p>For branches, we assumed that we won’t want to branch too far, so we can specify a <strong>change</strong> in the PC (SB-Format)</p>
<p>For general jumps(jal), we may jump to <strong>anywhere</strong> in code memory</p>
<ul>
<li>ideally, we would specify a 32-bit memory address to jump to</li>
<li>Unfortunately, we have a 7-bit <strong>opcode</strong></li>
<li>also, when linking we must write to an rd register</li>
</ul>
<p><img src="/Blog/intro/comp_sys/format_25.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_26.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>为什么 imm那么花哨? 是为了和别的指令对齐</p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/format_27.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/format_28.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p><img src="/Blog/intro/comp_sys/format_29.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>有两种寻址方式: PC相对寻址和寄存器相对寻址</p>
<p>jal, B-Format指令 : pc相对寻址, imm可以是负数, imm=4就是下跳转到一条指令(一条指令占4byte), 然而在实际存储是imm=2, 计算时会在二进制左边补一个0</p>
<p>PC = PC + imm</p>
<p><br></p>
<p>jalr : 寄存器相对寻址</p>
<p>PC = re1 + imm</p>
</blockquote>
<p><br></p>
<p><br></p>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>汇编如何执行function?</p>
<p>调用一个函数有几个问题:</p>
<p>如何传参, 执行完函数如何退出, 递归函数, 如何return value. 如果两个function有shared register 怎么进行管理?</p>
<p><br></p>
<ol>
<li>put arguments in a place where the function can access them</li>
<li>Transfer control to the function.</li>
<li>The function will acquire any(local storage) resources it needs.</li>
<li>The function perform its desired task</li>
<li>The function puts return value in an accessible place and “cleans up”</li>
<li>Control is returned to you.</li>
</ol>
<p><br></p>
<p>Jump 指令是不够的. jump只能跳过取, 但跳不回来.</p>
<p><br></p>
<p>有一个指令叫做 JAL (Jump and Link). 它会把新的地址放入PC指针中, 旧的地址放到x1中 (aka <strong>$ra</strong> or <strong>return address</strong>) </p>
<p><br></p>
<p>因此使用它就可以跳回原函数(将x1内的地址写入PC指针)</p>
<p>但如果连续调用函数呢? 毕竟x1只有一个, 但我们调用一个函数, 在新的函数内部再调用函数… …</p>
<p>如果再用 jal, 就会覆盖原本的return地址. </p>
<p><br></p>
<p>因此我们要用call stack. 简单来说就是每调用一个函数就往call stack中添加一个元素(返回地址)</p>
<p><strong>stack pointer(sp)</strong> keeps track of the top of the stack</p>
<p>dedicated register(x2) on the RISC-V</p>
<p>Manipulated by push/pop operations</p>
<ul>
<li>push: mpve sp down, store</li>
<li>pop: load, move sp up</li>
</ul>
<p><br></p>
<blockquote>
<p>其实我觉得可以这样理解, 当调用一个function时会传入a+1个参数, 最后一个参数是返回地址, 剩余的a个参数是正常的传参</p>
</blockquote>
<p>example:</p>
<p><img src="/Blog/intro/comp_sys/function_call.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Leaf: <br>addi sp,sp,-8  # adjust stack for 2 items<br>sw s1, 4(sp)   # save s1 for use afterwards<br>sw s0, 0(sp)   # save s0 for use afterwards<br>				# 用作临时变量<br><br>add s0,a0,a1 	# f = g + h<br>add s1,a2,a3 	# s1 = i + j<br>sub a0,s0,s1 	# return value (g + h) – (i + j)<br>lw s0, 0(sp) 	# restore register s0 for caller <br>lw s1, 4(sp) 	# restore register s1 for caller<br>addi sp,sp,8 	# adjust stack to delete 2 items<br>jr ra 		    # jump back to calling routine<br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/comp_sys/function_call_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>需要规定哪些寄存器在调用函数后改变, 哪些不改变</p>
<p><img src="/Blog/intro/comp_sys/function_call_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/function_call_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="约定"><a href="#约定" class="headerlink" title="约定:"></a>约定:</h3><ul>
<li><strong>first eight</strong> arg words passed in $a0-$a7</li>
<li>Space for args <strong>in child’s stack frame</strong></li>
<li>return value (if any) in $a0, $a1</li>
<li>stack frame ($fp to $sp) contains:<ul>
<li>$ra (clobbered on JALs)</li>
<li>local variables</li>
<li>space for 8 arguments to Callees(被调用者)</li>
<li>arguments 9+ to callees</li>
</ul>
</li>
<li>callee save regs: preserved</li>
<li>caller save regs: not preserved</li>
<li>global data accessed via $gp</li>
</ul>
<p><img src="/Blog/intro/comp_sys/convention_func.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Saved-Registers"><a href="#Saved-Registers" class="headerlink" title="Saved Registers"></a>Saved Registers</h3><p>这些寄存器在function调用前后的值不应该改变</p>
<p>如果被调用者(calleE) 使用了它们, 则必须在return之前重新将旧的值写入(保存旧值, 使用寄存器, 将旧值重新写入)</p>
<ul>
<li><p>s0-s11 (saved registers)</p>
</li>
<li><p>sp(stack pointer)</p>
</li>
<li>ra(return address)</li>
</ul>
<p><br></p>
<h3 id="Volatile-Register"><a href="#Volatile-Register" class="headerlink" title="Volatile Register"></a>Volatile Register</h3><p>这些寄存器可以被被调用函数随意使用</p>
<p>如果caller需要它们, 那么必须在call function 之前 save这些value</p>
<ul>
<li>t0-t6(temporary registers)</li>
<li>a0-a7(return address and arguments)</li>
</ul>
<p><img src="/Blog/intro/comp_sys/call_ex.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>register a1-a7用来传参, 但参数太多, 所以第8个参数用sp的stack存储</p>
<p>How many bytes do we need to allocate for the stack frame? 28</p>
<p><img src="/Blog/intro/comp_sys/call_ex_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<ul>
<li>Function does NOT call another function<ul>
<li>Use only t0-t6 and there is nothing to save. </li>
</ul>
</li>
<li>Function calls other function(s)<ul>
<li>Values you need throughout go in s0-s11, others go in t0-t6</li>
<li>At each function call, check number arguments and return values for whether you or not you need to save</li>
</ul>
</li>
</ul>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/data_str.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Frame-Pointer"><a href="#Frame-Pointer" class="headerlink" title="Frame Pointer"></a>Frame Pointer</h3><p>It is often cumbersome to keep track of location of data on the stack</p>
<ul>
<li>The offsets change as new values are pushed onto and popped off of the stack</li>
</ul>
<p><br></p>
<p>Keep a pointer to the bottom of the top stack frame</p>
<ul>
<li>Simplifies the task of referring to items on the stack</li>
</ul>
<p><br></p>
<p>A frame pointer, x8, aka fp/s0</p>
<ul>
<li><p>Value of sp upon procedure entry</p>
</li>
<li><p>Can be used to restore sp on exit</p>
</li>
</ul>
<p>退出一个function时, sp会回退到 frame pointer 的位置</p>
<p><img src="/Blog/intro/comp_sys/convention_func.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>然后fp指向上一个fp的位置(从saved fp中读取)</p>
</blockquote>
<p><br></p>
<h3 id="Data-Segment"><a href="#Data-Segment" class="headerlink" title="Data Segment"></a>Data Segment</h3><p><img src="/Blog/intro/comp_sys/data_seg.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Arrays-and-Data-Structures-in-Assembly"><a href="#Arrays-and-Data-Structures-in-Assembly" class="headerlink" title="Arrays and Data Structures in Assembly"></a>Arrays and Data Structures in Assembly</h2><p><img src="/Blog/intro/comp_sys/array.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/array_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>但如果是二维数组:</p>
<p><img src="/Blog/intro/comp_sys/array_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/array_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>由于每一行是5个元素. 每个元素占4byte.</p>
<p>所以如果传入i, 那么就应该返回20*i位置的地址</p>
<p>但是乘法没有位移和加法运算快, 所以就转换成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(i&lt;&lt;<span class="hljs-number">2</span> + i)&lt;&lt;<span class="hljs-number">2</span> + offset; <span class="hljs-comment">// offset + 5 * i * 4</span><br></code></pre></td></tr></table></figure>
<p>offset 是数组起始位置, i&lt;&lt;2相当于 i * 4, </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lui a0, %hi(.LANCHOR0)	# 读取.LANCHOR0的高位<br>addi a0, a0, %lo(.LANCHOR0) # 加上.LANCHOR0的低位<br></code></pre></td></tr></table></figure>
<p>这两句话相当于把.LANCHOR0 存储的信息写到a0中, 因为指令的大小有限, 所以只能拆分为两句</p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/array_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Multi-Level-Array"><a href="#Multi-Level-Array" class="headerlink" title="Multi-Level Array"></a>Multi-Level Array</h3><p>multi-level array 和 2D array 不一样</p>
<p>2D array 或者多维array 在内存中是连续的</p>
<p>但multi-level array不同:</p>
<p><img src="/Blog/intro/comp_sys/array_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/array_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时必须要load 两次. 第一次得到row array的pointer, 之后第二次访问元素.</p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/array_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>例子:</p>
<p><img src="/Blog/intro/comp_sys/array_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>使用O1优化把for-loop变为do-while loop(因为 *z 比 z[i] 的效率高)</p>
<p><img src="/Blog/intro/comp_sys/array_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Assembler-Complier-and-Linker"><a href="#Assembler-Complier-and-Linker" class="headerlink" title="Assembler, Complier and Linker"></a>Assembler, Complier and Linker</h2><p>c语言程序是如何转化为汇编语言程序?</p>
<p><img src="/Blog/intro/comp_sys/array_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Assembler"><a href="#Assembler" class="headerlink" title="Assembler"></a>Assembler</h3><p><img src="/Blog/intro/comp_sys/array_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>RISC-V中的指令</p>
<p><img src="/Blog/intro/comp_sys/array_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>有一些指令有别名(或者说是简写)</p>
<p><img src="/Blog/intro/comp_sys/array_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/array_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Symbols-and-reference"><a href="#Symbols-and-reference" class="headerlink" title="Symbols and reference"></a>Symbols and reference</h3><p><img src="/Blog/intro/comp_sys/array_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>生成machine language</p>
<ul>
<li>Simple Cases<ul>
<li>Arithmetic and logical instructions, shifts, etc.</li>
<li>All necessary info contained in the instruction</li>
</ul>
</li>
<li>What about Branches and Jumps?<ul>
<li>Branches and Jumps require a <em>relative address</em></li>
<li>Once pseudo-instructions are replaced by real ones, we know by how many instructions to branch, so no problem</li>
</ul>
</li>
</ul>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/array_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>编译会扫描文件两次:</p>
<p><img src="/Blog/intro/comp_sys/array_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Object-File"><a href="#Object-File" class="headerlink" title="Object File"></a>Object File</h3><p><img src="/Blog/intro/comp_sys/obj_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="Object-File-format"><a href="#Object-File-format" class="headerlink" title="Object File format"></a>Object File format</h4><p><img src="/Blog/intro/comp_sys/obj_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>当生成obj file时, 会留有一些空余, 因为有些函数或语句定义在文件外面</p>
<p><img src="/Blog/intro/comp_sys/obj_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/obj_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h2 id="Linker"><a href="#Linker" class="headerlink" title="Linker"></a>Linker</h2><p><img src="/Blog/intro/comp_sys/obj_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/obj_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/obj_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/obj_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/obj_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="三种类型寻址"><a href="#三种类型寻址" class="headerlink" title="三种类型寻址"></a>三种类型寻址</h3><ul>
<li>PC-Relative Addressing(beq, bne, jal)<ul>
<li><strong>never relocate</strong></li>
</ul>
</li>
<li>External Function Reference(usually jal)<ul>
<li><strong>always relocate</strong></li>
</ul>
</li>
<li>Static Data Reference (often auipc and addi)<ul>
<li><strong>always relocate</strong></li>
<li>RISC-V often uses auipc rather than lui so that a big block of stuff can be further relocated as long as it is fixed relative to the pc</li>
</ul>
</li>
</ul>
<p><img src="/Blog/intro/comp_sys/obj_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>link printf function</p>
<p><img src="/Blog/intro/comp_sys/obj_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>link global data (usrid and pi)</p>
<p><img src="/Blog/intro/comp_sys/obj_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>有了可执行文件不代表可以执行.</p>
<p><img src="/Blog/intro/comp_sys/loader.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<ol>
<li><p>Reads executable file’s header to determine size of text and data segments</p>
</li>
<li><p>Creates new address space for program large enough to hold text and data segments, along with a stack segment </p>
</li>
<li><p>Copies instructions and data from executable file into the new address space</p>
</li>
<li>Copies arguments passed to the program onto the stack</li>
<li>Initializes machine registers<ul>
<li>Most registers cleared, but stack pointer assigned address of 1st free stack location</li>
</ul>
</li>
<li>Jumps to start-up routine that copies program’s arguments from stack to registers and sets the PC<ul>
<li>If main routine returns, start-up routine terminates program with the exit system call</li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="静态连接和动态连接"><a href="#静态连接和动态连接" class="headerlink" title="静态连接和动态连接"></a>静态连接和动态连接</h3><p><img src="/Blog/intro/comp_sys/loader_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>summary</p>
<p><img src="/Blog/intro/comp_sys/loader_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>complier: 把文件转化为汇编语言的文件</p>
<p>assembler: 把汇编文件转换为机器码(有些地方有空缺, 需要其他汇编文件)</p>
<p>linker: 整合所有机器码文件(object file)形成可执行文件</p>
<p>loader: load可执行文件, 并执行</p>
</blockquote>
<p><br></p>
<p><br></p>
<h2 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h2><p>在计算机中是如何表示浮点数的?</p>
<ol>
<li>Real number (eg. 3.14159)</li>
<li>very large number (eg $6.02\times 10^{23}$)</li>
<li>very small numbers(eg $6.626\times 10^{-34}$)</li>
<li>special numbers (eg. inf, NaN)</li>
</ol>
<p><br></p>
<p>分数的表示</p>
<p><img src="/Blog/intro/comp_sys/floating_point.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>科学表示法</p>
<p><img src="/Blog/intro/comp_sys/floating_point_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Normalized form: exactly one digit(non-zero) to left of decimal point.</p>
<p><img src="/Blog/intro/comp_sys/floating_point_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><strong>binary 的科学表示法</strong></p>
<p><img src="/Blog/intro/comp_sys/floating_point_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Computer arithmetic that supports this called floating point due to the “floating” of the binary point</p>
<ul>
<li>Declare such variable in C as float (or double)</li>
</ul>
<p><br></p>
<h3 id="二进制Floating和十进制小数的转换"><a href="#二进制Floating和十进制小数的转换" class="headerlink" title="二进制Floating和十进制小数的转换"></a>二进制Floating和十进制小数的转换</h3><p><img src="/Blog/intro/comp_sys/floating_point_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="floating-point-encoding"><a href="#floating-point-encoding" class="headerlink" title="floating point encoding"></a>floating point encoding</h3><p>科学家希望floating point 准确, 工程师想要它运算快速. 然而它依然比integer的运算慢很多.</p>
<p>Operating System 根本不用任何float</p>
<p><img src="/Blog/intro/comp_sys/floating_point_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>计算机的floating point 由三个部分组成: sign, matissa, exponent</p>
<p> 由于科学计数法的第一位一定是1, 所以完全可以不表示</p>
<p><br></p>
<h3 id="bias"><a href="#bias" class="headerlink" title="bias"></a>bias</h3><p><img src="/Blog/intro/comp_sys/floating_point_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>为什么使用bias? bias 为 127</p>
<ul>
<li><p>Makes floating point arithmetic easier</p>
</li>
<li><p>Makes somewhat compatible with two’s complement</p>
</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">E</span> = <span class="hljs-number">1</span>      → <span class="hljs-number">128</span>  → <span class="hljs-number">0</span>b <span class="hljs-number">1000</span> <span class="hljs-number">0000</span><br><span class="hljs-attribute">E</span> = <span class="hljs-number">127</span>    → <span class="hljs-number">254</span>  → <span class="hljs-number">0</span>b <span class="hljs-number">1111</span> <span class="hljs-number">1110</span><br><span class="hljs-attribute">E</span> = -<span class="hljs-number">63</span>    → <span class="hljs-number">64</span>   → <span class="hljs-number">0</span>b <span class="hljs-number">0100</span> <span class="hljs-number">0000</span><br></code></pre></td></tr></table></figure>
<p>读取exp as unsigned integer, 也就是说有127 的偏移量. 也就是说exp(指数位)最大为127.  (因为最大只能表示254, 减去127的偏移就是127)</p>
<p>如果我们对两个浮点型进行比较. 首先会比较sing位, 之后比较exp位, 例如, $2^{127}&gt;2^1$</p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/floating_point_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="精确度-Precision-and-Accuracy"><a href="#精确度-Precision-and-Accuracy" class="headerlink" title="精确度 Precision and Accuracy"></a>精确度 Precision and Accuracy</h3><p><strong>Percision</strong> is a count of the number of bits in a computer word used to represent a value</p>
<ul>
<li>capacity for accuracy</li>
</ul>
<p><strong>Accuracy</strong> is a measure of the difference between the actual value of a number and its computer representation</p>
<ul>
<li><em>High precision permits high accuracy but doesn’t guarantee it. It is possible to have high precision but low accuracy.</em></li>
</ul>
<p>例如 <code>float pi = 3.14</code></p>
<p>pi 将使用24bit的mantissa(high mantissa, high percision), 但是这只能表示近似值(not accuracy)</p>
<p><br></p>
<h3 id="double"><a href="#double" class="headerlink" title="double"></a>double</h3><p><img src="/Blog/intro/comp_sys/floating_point_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>double 扩充了Mantissa 位数以及exp位数, 所以更准确</p>
<p>此时exp的bias就是1023</p>
<p><br></p>
<p><br></p>
<h3 id="如果exp和mantissa-significand-为0-0"><a href="#如果exp和mantissa-significand-为0-0" class="headerlink" title="如果exp和mantissa(significand)为0(0)"></a>如果exp和mantissa(significand)为0(0)</h3><p>如果exp位和mantissa(significand)位全是0. 理论上是$1.0*2^0=1$</p>
<p><img src="/Blog/intro/comp_sys/floating_point_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>然而在很多情况下, 我们需要用float表示0, 所以我们把这个作为一个特出情况, 当exp位和mantissa位全是0时, float值为0</p>
<p><br></p>
<h3 id="如果exp全为1-mantissa-significand-全为0-正负无穷"><a href="#如果exp全为1-mantissa-significand-全为0-正负无穷" class="headerlink" title="如果exp全为1, mantissa(significand) 全为0(正负无穷)"></a>如果exp全为1, mantissa(significand) 全为0(正负无穷)</h3><p>同理定义另外两种特殊情况, 当exp全为1时, exp = 255 - 127</p>
<p><img src="/Blog/intro/comp_sys/floating_point_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时我们将他们定义为正负无穷.</p>
<p><br></p>
<h3 id="如果exp全为1-mantissa-significand-不全为0-NaN"><a href="#如果exp全为1-mantissa-significand-不全为0-NaN" class="headerlink" title="如果exp全为1, mantissa(significand) 不全为0(NaN)"></a>如果exp全为1, mantissa(significand) 不全为0(NaN)</h3><p><img src="/Blog/intro/comp_sys/floating_point_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="如果exp为0-mantissa-significand-不全为0"><a href="#如果exp为0-mantissa-significand-不全为0" class="headerlink" title="如果exp为0, mantissa(significand)不全为0"></a>如果exp为0, mantissa(significand)不全为0</h3><p>这种方式可以表示很小的值</p>
<p>但问题是这样表达的值距离0有多近.</p>
<p>如果有leading 1, 距离0和最小的表示之间会有一大段空隙</p>
<p><img src="/Blog/intro/comp_sys/floating_point_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/floating_point_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时就没有leading 1.因为我们要表示非常小的数</p>
<p><br></p>
<p>总结:</p>
<p><img src="/Blog/intro/comp_sys/floating_point_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Converting-From-Hex-and-Decimal"><a href="#Converting-From-Hex-and-Decimal" class="headerlink" title="Converting From Hex and Decimal"></a>Converting From Hex and Decimal</h3><p>Convert <code>0x40600000</code> to decimal</p>
<p>1 bit for sign, 8 bits for exponent, 23 bits for significand, bias of -127</p>
<p><br></p>
<h4 id="第一步-转为二进制"><a href="#第一步-转为二进制" class="headerlink" title="第一步, 转为二进制"></a>第一步, 转为二进制</h4><p>首先转为2进制 <code>0x40600000 = 0100 0000 0110 0000 0000 0000 0000 0000</code></p>
<p><br></p>
<h4 id="第二步-拆分bit位"><a href="#第二步-拆分bit位" class="headerlink" title="第二步, 拆分bit位"></a>第二步, 拆分bit位</h4><p><img src="/Blog/intro/comp_sys/floating_point_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="第三步-check-if-Norm-Denorm"><a href="#第三步-check-if-Norm-Denorm" class="headerlink" title="第三步, check if Norm/Denorm"></a>第三步, check if Norm/Denorm</h4><p><img src="/Blog/intro/comp_sys/floating_point_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="第四步-套公式算值"><a href="#第四步-套公式算值" class="headerlink" title="第四步, 套公式算值"></a>第四步, 套公式算值</h4><p><img src="/Blog/intro/comp_sys/floating_point_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Converting-From-Decimal-to-Binary"><a href="#Converting-From-Decimal-to-Binary" class="headerlink" title="Converting From Decimal to Binary"></a>Converting From Decimal to Binary</h3><p>convert <code>-5.625</code> to binary</p>
<h4 id="第一步-convert-left-side-of-decimal"><a href="#第一步-convert-left-side-of-decimal" class="headerlink" title="第一步 convert left side of decimal"></a>第一步 convert left side of decimal</h4><p><img src="/Blog/intro/comp_sys/floating_point_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="第二步-convert-right-side-of-decimal"><a href="#第二步-convert-right-side-of-decimal" class="headerlink" title="第二步 convert right side of decimal"></a>第二步 convert right side of decimal</h4><p><img src="/Blog/intro/comp_sys/floating_point_19.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="第三步-合并并且normalize结果"><a href="#第三步-合并并且normalize结果" class="headerlink" title="第三步, 合并并且normalize结果"></a>第三步, 合并并且normalize结果</h4><p><img src="/Blog/intro/comp_sys/floating_point_20.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="第四步-转换为binary"><a href="#第四步-转换为binary" class="headerlink" title="第四步, 转换为binary"></a>第四步, 转换为binary</h4><p><img src="/Blog/intro/comp_sys/floating_point_21.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="值的分布"><a href="#值的分布" class="headerlink" title="值的分布"></a>值的分布</h3><p>哪些范围内的值无法表述?</p>
<ul>
<li>between largest nrom and infinity (<strong>overflow, exp too large</strong>)</li>
<li>between zero and smallest denorm(<strong>underflow, exp too small</strong>)</li>
<li>between norm numbers? (Rounding)</li>
</ul>
<p><img src="/Blog/intro/comp_sys/floating_point_22.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>当在无法精确表达时, 会进行四舍五入</p>
<p><img src="/Blog/intro/comp_sys/floating_point_23.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>当进行浮点运算时, 会先计算出精确值, 再round来fit bits</p>
<p><img src="/Blog/intro/comp_sys/floating_point_24.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/floating_point_25.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Casting"><a href="#Casting" class="headerlink" title="Casting"></a>Casting</h3><p><img src="/Blog/intro/comp_sys/floating_point_26.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Caches"><a href="#Caches" class="headerlink" title="Caches"></a>Caches</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[SIZE];<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">200000</span>; i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SIZE; j++)&#123;<br>        sum += <span class="hljs-built_in">array</span>[j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们将对比不同SIZE这段程序执行的时间.</p>
<p><img src="/Blog/intro/comp_sys/cache.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>可以看到有一个转折点, 在那之前, 程序运行消耗时间增长很慢</p>
<p>也就是说在那个点之前, 数组的size fit the cache. 在那个点之后, size does not fit the cache.</p>
<p> <br></p>
<p>再看另一个例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SIZE; j++)&#123;<br>        sum += <span class="hljs-built_in">array</span>[i][j];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; SIZE; j++)&#123;<br>        sum += <span class="hljs-built_in">array</span>[j][i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这两种访问2D array的方法, 上面一种是沿着行进行访问, 下面那种是沿着列进行访问</p>
<p>理论上来说, 这两段代码所做的事情是一样的, 都是遍历一遍整个2D数组</p>
<p><img src="/Blog/intro/comp_sys/cache_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>然而实际上沿着行遍历, 远远快于沿着列遍历</p>
<p>因为沿着行遍历遍历的是一片连续的内存空间.</p>
<p><br></p>
<p>另一个例子:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i+stride)&#123;<br>    sum += <span class="hljs-built_in">array</span>[i];<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/Blog/intro/comp_sys/cache_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>为什么当步长在1-16之间时, 消耗时间差不多, 但当步长大于16时, 消耗的时间极速增加</p>
<p>在软件层面, 看起来都是一样地访问<code>array[i]</code>. 然而在硬件层面, it touches it as a function of blocks. 如果访问同一个block中的bytes, 消耗就低, 而如果跳过一些block, 消耗就高</p>
<p>我们尝试访问一个block中尽可能多的bytes. </p>
<p><br></p>
<p>cpu执行的操作都是快速的, 任何和memory相关的操作都是慢的.</p>
<p>无论lw, lb, lh, sw, sb, sh… 它们的速度都很慢.</p>
<p>我们希望提高访问内存的速度. 这就是cache的作用.</p>
<p><br></p>
<p> Cache</p>
<p><img src="/Blog/intro/comp_sys/cache_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Cache 用于存储<strong>经常使用</strong>或<strong>近期使用</strong>的数据</p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/cache_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这里的数字代表地址.</p>
<p>如果此时请求14, 地址为14的数据在缓存中, hit. 就不需要访问内存中的数据. 减少了内存访问的开销</p>
<p><img src="/Blog/intro/comp_sys/cache_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>然而如果请求12, 12 不在缓存中, miss.</p>
<p>因此要把12从内存读到缓存, 把缓存中的某一个数据(9)替换为12.</p>
<p><img src="/Blog/intro/comp_sys/cache_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="为什么Cache有用"><a href="#为什么Cache有用" class="headerlink" title="为什么Cache有用?"></a>为什么Cache有用?</h3><p>局部性：程序倾向于使用地址或地址与它们最近使用的地址接近或相等的数据和指令</p>
<p>时间局部性: 最近引用的项目可能会在不久的将来再次引用</p>
<p>空间局部性: 如果一个地址被引用, 那么附近的地址可能也会被引用</p>
<p><img src="/Blog/intro/comp_sys/cache_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/cache_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/cache_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>例如这个例子, 每一次访问数组都至少要跳过4个元素</p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/cache_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这个3d array的例子, 每一次访问数组至少跳过12个元素</p>
<p><br></p>
<p>Cache hit 和 Cache miss 有着巨大的不同</p>
<p>二者近乎有100倍速度的差距, 因此什么hit了, 什么miss了非常重要</p>
<p>因此有一些相关的概念</p>
<ul>
<li><strong>Miss Rate(MR)</strong>: Fraction of memory references not found in cache (misses / accesses) = 1 - Hit Rate </li>
<li><strong>Hit Time(HT)</strong>: Time to deliver a block in the cache to the processor (Includes time to determine whether the block is in the cache)</li>
<li><strong>Miss Penalty (MP)</strong>: Additional time required because of a miss</li>
</ul>
<p><br></p>
<p>我们如何计算cache performance?</p>
<p>我们实际计算的是平均内存访问时间.</p>
<p>换句话说就是假设我们进行多次内存访问, 可能hit可能miss, 最后求平均时间.</p>
<p><em>Average Memory Access Time</em> (AMAT): average time to access memory considering both hits and misses</p>
<p> <strong>AMAT = Hit time + Miss rate × Miss penalty</strong></p>
<p> (abbreviated AMAT = HT + MR × MP)</p>
<p><br></p>
<p>99% 的HT是 97% HT性能的两倍:</p>
<ul>
<li><p>HR = .97 -&gt; 1 + .03 * 100 = 4 cycles</p>
</li>
<li><p>HR = .99 -&gt; 1 + .01 * 100 = 2 cycles</p>
</li>
</ul>
<p><br></p>
<p>例题:</p>
<p><img src="/Blog/intro/comp_sys/cache_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<blockquote>
<p>答案: C</p>
<p>AMAT = 1 + .02 * 50 = 2 cycles = 400 ps (trillionth!)</p>
<p>A -&gt; 2 cycles -&gt; 380 ps</p>
<p>B -&gt; 1 + 0.02 * 40 = 1.8 cyc = 360ps</p>
<p>C -&gt; 1 + 0.015 * 50 = 1.75 cyc = 350ps</p>
</blockquote>
<p><br></p>
<h3 id="能否有多个cache"><a href="#能否有多个cache" class="headerlink" title="能否有多个cache?"></a>能否有多个cache?</h3><p>我们希望尽可能减少访问内存的可能.</p>
<p><img src="/Blog/intro/comp_sys/cache_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>这种多重cache叫做Memory Hierarchies.</p>
<p><img src="/Blog/intro/comp_sys/cache_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/cache_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Cache-Organization"><a href="#Cache-Organization" class="headerlink" title="Cache Organization"></a>Cache Organization</h3><p><strong>Block Size(K):</strong> Cache 和 Memory 每次进行数据传输时, 并不会只专递 1 byte. 而是将”一块”(Block) 内存整体传递过去.</p>
<p>而Block Size依然是几个byte. 通常是power of 2 (例如 64B)</p>
<p>Block consist of adjacent bytes(different in address by 1)</p>
<p><br></p>
<h4 id="offset-field"><a href="#offset-field" class="headerlink" title="offset field"></a>offset field</h4><p>假设我们有一个m bit address</p>
<p>我们将它低k位作为一个block</p>
<p><img src="/Blog/intro/comp_sys/cache_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们将原本的m bit 分为两部分区域, block number 和 block offset</p>
<p>block number 是指有多少block, block offset是指每个block的大小</p>
<p><br></p>
<p>例题:</p>
<p><img src="/Blog/intro/comp_sys/cache_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>0x15 二进制表示为 0b00010101</p>
<p>而由于是6-bit 地址, 所以取最后6位 0b010101</p>
<p>已知K = 4, 那么offset=$\log_2 k=2$</p>
<p>所以最后两位就是offset, offset=0b01, block number 就是前四位 $0b0101=5$</p>
<p>所以答案是C.</p>
<p><br></p>
<p><br></p>
<p><strong>Cache Size(C)</strong>: cache 可以存储多少数据</p>
<p>Give in bytes (C) or number of blocks(C/K)</p>
<p>例如 C = 32 KiB = 512 Blocks if using 64-B blocks.</p>
<p><br></p>
<p>然而当cache和memory交互的时候, 数据会放到哪里?</p>
<p>因此我们需要一组映射: from memory address to specific locations in the cache to make checking the cache for an address fast.</p>
<p>因此使用hashtable来实现它, cache 是一个 hardware hashtable</p>
<p> <img src="/Blog/intro/comp_sys/cache_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Map to <strong>cache index</strong> from block address.</p>
<p>而我们之前也说过, 当访问一个block时, 它相邻的block也可能会被访问</p>
<p>Consecutive blocks go in consecutive cache indices</p>
<p><br></p>
<p>举个例子:</p>
<p>6-bit address, block size K=4 B, cache holds S = 4 blocks</p>
<p>如果请求0x2A, cache miss, 问 除了这个地址, 我们还会load哪些地址?</p>
<p>0x2A = 0b101010.</p>
<p>这个地址分为两部分, $K = 4 = 2^2$, 所以最后两位是offset, 前4位是block number</p>
<p>我们将读取 0b1010__</p>
<p>也就是 0b101000=0x28, 0b101001=0x29, 0b101010=0x2A, 0b101011=0x2B</p>
<p>因此其余3个地址分别是0x28, 0x29, 0x2B</p>
<p><br></p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/cache_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>然而还有一个问题: 对于 0110 这个地址存入 10 cache中, 然而我们怎么直到10代表0110, 因为0010, 1010, 1110 都有可能写入10这个cache中.</p>
<p>因此对于cache只有index是不够的. 还要有一个tag</p>
<p><img src="/Blog/intro/comp_sys/cache_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>在这个例子中用address的后两位作为index, 而用前两位作为tag</p>
<p>用k bit 作为block offset, m-s作为block address, s 是cache index</p>
<p><img src="/Blog/intro/comp_sys/cache_19.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这种方式叫做TIO, tag index offset</p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/cache_20.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>0-16, 17个地址</p>
<p>如果4byte为一个block, [0-3] [4-7] [8-11] [12-15] [16] 可以这样分为5个block, 14, 15在同一个block中, ,16和他们在一个block中, 所以cache可能是4 byte 一个block.</p>
<p>同理也可能是8, 16 bytes. 因此答案就是D. 32 byte一个block</p>
<p><br></p>
<p>然而既然是用hash map 实现的 cache, 那么hash map有的缺点 cache就都有, 如果我们访问8, 25, 8, 25, 8, 25…</p>
<p>8 是 0b001000, 25 是 0b011001.</p>
<p>刨去最后两位是offset, 8 的 index 就是10, 25的index也是10.</p>
<p>此时就是连续访问<code>10</code>这个index</p>
<p><img src="/Blog/intro/comp_sys/cache_21.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="Associativity"><a href="#Associativity" class="headerlink" title="Associativity"></a>Associativity</h4><p>如果我们能在cache的任意地方存储数据?</p>
<p>我们要结合两个idea:</p>
<ul>
<li>Each address, maps to exactly one <strong>set</strong></li>
<li>Each set can store block in more than one <strong>way</strong></li>
</ul>
<p><img src="/Blog/intro/comp_sys/cache_22.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>我们只是改变how we organize it.</p>
<p>例如上图如果是8 sets. 如果发生冲突则必须扔掉一个, 而如果是4set, 则允许一次冲突, 一个index可以存储2个元素. 不过每次search也要遍历这2个元素.</p>
<p><br></p>
<p><strong>Associativity(E)</strong> number of ways for each set</p>
<p>这种cache 叫做 E-way set associative cache.</p>
<p>此时我们index cache sets $S=(C/K)/E$</p>
<p>$\log_2(C/K/E)=s$ bits of block address.</p>
<ul>
<li>direct-mapping: E=1, 因此 $s=\log_2(C/K)$</li>
<li>Fully associative: E=C/K, 因此 $s=0$ bits</li>
</ul>
<p><br></p>
<p>例题:</p>
<p><img src="/Blog/intro/comp_sys/cache_23.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>首先算offset, offset = $\log_2K=\log_216=4$ 所以最后4位是offset.</p>
<p>如果是第一种情况, 8个set, $s=\log_28=3$, 因此刨去offset后的倒数3位是index, 也就是011, 也就是说第一种情况, 将会map到set 3.</p>
<p>如果是第二种情况,  每个set能容纳2个元素 $E=2$ 因此总共有4个set</p>
<p>$s=\log_24=2$, 刨去offset后倒数2位是index, 也就是11, 同样map到set 3</p>
<p>同理第3种情况 $s=\log_22=1$, index=1, map到set 1</p>
<p><img src="/Blog/intro/comp_sys/cache_24.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>然而如果set满了, 我们应该覆盖掉那个block?</p>
<p>Caches typically use something close to <strong>least recently used <a target="_blank" rel="noopener" href="https://leetcode.com/problems/lru-cache/">(LRU)</a></strong><br> (hardware usually implements “<em>not most recently used</em>”)</p>
<p><br></p>
<p>例题:</p>
<p><img src="/Blog/intro/comp_sys/cache_25.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>$2*1024/128/2=8$ 所以 associativity=8</p>
<p>如果block size=128B = $2^7$, 那么末尾7位就是offset, 而由于是由2个set=$2^1$, 倒数第8位用作index, tag size = 16-1-7=8位.</p>
<p><br></p>
<p><br></p>
<h3 id="General-Cache-Organization"><a href="#General-Cache-Organization" class="headerlink" title="General Cache Organization"></a>General Cache Organization</h3><p><img src="/Blog/intro/comp_sys/cache_26.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/cache_27.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>看cache是否存储了某个数据</p>
<p><img src="/Blog/intro/comp_sys/cache_28.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/cache_29.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/cache_30.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/cache_31.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/cache_32.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/cache_33.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p>例题:</p>
<p><img src="/Blog/intro/comp_sys/cache_34.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>long 是 8byte, K=32意味着每个block有32个byte, 也就是说每进行一次数据交互, memory都会有32byte进入cache.</p>
<p>也就是每一次cache读取4个long, 也就是每4次访问数组会有一次miss(第一次miss, 剩余3次hit) 因此 miss rate = $1/4$ (正好访问完数组)</p>
<blockquote>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">k =<span class="hljs-number"> 5 </span>bits<br>256 /<span class="hljs-number"> 32 </span>=<span class="hljs-number"> 8 </span>blocks <br>8 /<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 4 </span>sets<br>s =<span class="hljs-number"> 2 </span>bits<br>t =<span class="hljs-number"> 12 </span>–<span class="hljs-number"> 5 </span>–<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 5 </span>bits<br><br>0x800 = 0b<span class="hljs-number"> 1000 </span>0000 0000<br>8 bytes per elem<br>4 longs fit in a block<br>¼ miss rate (missed are compulsory)<br></code></pre></td></tr></table></figure>
</blockquote>
<p><br></p>
<p><br></p>
<p>那么write 呢?</p>
<p>如果我们write到memroy 那么cache中的就都是旧数据了</p>
<p>尤其是由多层 level (L1, L2, L3) 的 cache</p>
<p><img src="/Blog/intro/comp_sys/cache_35.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>实际上就是个懒加载, 如果向一个地址store一个值, 就store在cache中(标记为dirty), 之后访问地址依然是通过cache, 但当要覆盖这个地址时, 如果是dirty 则进行数据交互, 将cache的值写入memory, 之后清空cache再执行命令.</p>
<p><img src="/Blog/intro/comp_sys/cache_36.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/cache_37.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/cache_38.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/cache_39.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/cache_40.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/cache_41.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Cache-Miss-的3个原因"><a href="#Cache-Miss-的3个原因" class="headerlink" title="Cache Miss 的3个原因"></a>Cache Miss 的3个原因</h3><p>3C:</p>
<ul>
<li><strong>Compulsory:</strong> (Many names: cold start, process migration 1st reference)<ul>
<li>这是不可避免的miss, 就像刚开始启动cache, 什么元素都没有, 肯定会miss. 或者访问的地址之前没有存储过, 一定会miss. 通过这次miss 从内存中读取一个block的数据</li>
</ul>
</li>
<li><strong>Capacity</strong>: 第二种可能是因为Cache的容量有限, 无法存储所有program中的所有block</li>
<li><strong>Confilct:</strong> 冲突时就会从cache中丢去元素. 如果我们再访问就会miss</li>
</ul>
<p><br></p>
<p>3C的解决办法:</p>
<ul>
<li>Compulsory的解决办法, 使用尽可能大的block. 这样每一次交互都能带来更多的数据. 减少需要交互的次数.<ul>
<li>然而这依然可能导致 MP(Miss Penalty), 因为block太大会增加MR(Missing rate)的可能. 因此cache就那么大, 如果交互一次数据多了, confilct的可能就大了</li>
</ul>
</li>
<li>Capacity的解决办法: 增加cache size(可能会增加HT(Hit Time))</li>
<li>Conflict 的解决办法: 增加associativity(to fully associative) (可能会增加HT)</li>
</ul>
<p>判断是那种miss</p>
<p><img src="/Blog/intro/comp_sys/cache_42.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>capacity miss 这里我仔细说说:</p>
<p>假设我们访问B, 结果miss了. </p>
<p>我们要看上一次访问B和这一次访问B之间访问的其他的block.</p>
<p>如果这期间访问的不同(unique)的block的数目大于cache能存储的block的数目, 则说是capacity miss. 反之是conflict miss</p>
<p><img src="/Blog/intro/comp_sys/cache_43.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p>正如上图所示, 现在的计算机有多层cache.L1缓存, L2缓存..</p>
<p><img src="/Blog/intro/comp_sys/cache_44.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>实际上思想也很简单. 我们可以访问L1时, 可以把L1当作缓存, L2到memory都看作memory. 这就和之前讲的一样了, 访问L2时, 把L2之下的看作memory, L2之上的看作CPU.</p>
<p><br></p>
<p>不同层的cache也可以有不同分工:</p>
<ul>
<li>L1cache focuses on <em>low hit time</em> (fast access) 快速访问</li>
<li>L2 cache, L3 cache focus on <em>low miss rate</em></li>
</ul>
<p><br></p>
<p>此时AMAT就是一个递归算法了:</p>
<p><img src="/Blog/intro/comp_sys/cache_45.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>因此由引出了两个概念: local missrate 和 global missrate</p>
<p><img src="/Blog/intro/comp_sys/cache_46.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Global missrate 等于所有local missrate的乘积</p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/cache_47.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/cache_48.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/cache_49.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h2><h3 id="control-flow"><a href="#control-flow" class="headerlink" title="control flow"></a>control flow</h3><p><strong>Exceptional control flow</strong> is basic mechanism used for:</p>
<ul>
<li><p>Transferring control between <em>processes</em> and OS</p>
</li>
<li><p>Handling <em>I/O</em> and <em>virtual memory</em> within the OS</p>
</li>
<li><p>Implementing multi-process apps like shells and web servers</p>
</li>
<li><p>Implementing concurrency</p>
</li>
</ul>
<p><img src="/Blog/intro/comp_sys/control_flow.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>目前有两种方法可以change control flow:</p>
<ol>
<li>jump</li>
<li>Call and return</li>
</ol>
<p>Both react to change in <strong>program state.</strong></p>
<p>然而 Processor 需要react to change in <strong>system state</strong></p>
<ul>
<li><p>Unix/Linux user hits “Ctrl-C” at the keyboard</p>
</li>
<li><p>User clicks on a different application’s window on the screen</p>
</li>
<li><p>Data arrives from a disk or a network adapter</p>
</li>
<li><p>Instruction divides by zero</p>
</li>
<li><p>System timer expires</p>
</li>
</ul>
<p>然而jump和call无法应对这些问题. 所以系统需要<strong>exceptional</strong> control flow</p>
<p><img src="/Blog/intro/comp_sys/control_flow_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_flow_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<ul>
<li>An <em>exception</em> is transfer of control to the operating system (OS) kernel in response to some <em>event</em> (<em>i.e.</em> change in processor state)<ul>
<li>Kernel is the memory-resident part of the OS</li>
<li>Examples: division by 0, page fault, I/O request completes, Ctrl-C</li>
</ul>
</li>
</ul>
<p>然而system怎么知道需要跳转到哪里? </p>
<p>这就是中断向量表的作用:</p>
<p><img src="/Blog/intro/comp_sys/control_flow_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_flow_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>异步异常:</p>
<p><img src="/Blog/intro/comp_sys/control_flow_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>同步异常:</p>
<p><img src="/Blog/intro/comp_sys/control_flow_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="什么是process"><a href="#什么是process" class="headerlink" title="什么是process?"></a>什么是process?</h3><p><img src="/Blog/intro/comp_sys/control_flow_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>process其实是一种错觉: 这是在cpu上运行的唯一一个软件</p>
<p>什么是process? 什么是program? 什么是processor?</p>
<p><br></p>
<p>process 是一个 running program 的实例</p>
<p><img src="/Blog/intro/comp_sys/control_flow_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>每个进程都有自己的内存空间, 彼此之间互不影响</p>
<p><img src="/Blog/intro/comp_sys/control_flow_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>错觉: 每个程序都<strong>感觉</strong>自己有cpu和memory的整个的控制权</p>
<p><img src="/Blog/intro/comp_sys/control_flow_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>然而实际上processor也就是cpu是在这些process中来回切换的</p>
<p><img src="/Blog/intro/comp_sys/control_flow_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_flow_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_flow_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>对于多核处理器来说就有多个processor.</p>
<p><img src="/Blog/intro/comp_sys/control_flow_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>我们的机器可能没有 $2^w$ byte memory, 而且肯定无法为每一个process提供 $2^w$ byte memory</p>
<p>然而每一个process都觉得自己拥有这个内存空间</p>
<p>这里有几个问题:</p>
<p><img src="/Blog/intro/comp_sys/control_flow_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_flow_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_flow_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>所有计算机的问题都可以通过增加一层抽象来解决.</p>
<p><img src="/Blog/intro/comp_sys/control_flow_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_flow_19.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>互联网来发中也有类似的概念: 网关</p>
<p><br></p>
<p><strong>如果系统使用物理内存:</strong></p>
<p>cpu对内存进行直接访问</p>
<p><img src="/Blog/intro/comp_sys/control_flow_20.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>通常简单的系统会使用这种方法.</p>
<p><br></p>
<p><strong>如果系统使用虚拟内存</strong></p>
<p>程序永远无法知道真实的物理内存</p>
<p><img src="/Blog/intro/comp_sys/control_flow_21.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_flow_22.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_flow_23.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>和cache一样, 我们要尽量避免disk的访问</p>
<ul>
<li><p>The set of virtual pages that a program is “actively” accessing at any point in time is called its <em>working set</em></p>
<ul>
<li><p>If (<em>working set of one process</em> ≤ <em>physical memory</em>):</p>
<ul>
<li>Good performance for one process (after compulsory misses)</li>
</ul>
</li>
<li><p>If (<em>working sets of all processes</em> &gt; <em>physical memory</em>):</p>
<ul>
<li><strong>Thrashing:</strong> Performance meltdown where pages are swapped between memory and disk continuously (CPU always waiting or paging)</li>
<li>This is why your computer can feel faster when you add RAM</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p><img src="/Blog/intro/comp_sys/control_flow_24.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_flow_25.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>例题:</p>
<p>已知: </p>
<ol>
<li><p>16 KiB pages</p>
</li>
<li><p>48-bit virtual addresses</p>
</li>
<li><p>16 GiB physical memory</p>
</li>
</ol>
<p>问 How many bits wide are the following fields?</p>
<p><img src="/Blog/intro/comp_sys/control_flow_26.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>解:</p>
<p>16 KiB page = $2^4\cdot 2^{10} = 2^{14}$Byte, 所以virtual page 的 offset =14,</p>
<p>而virtual address是48bit, 刨去14位offset, 48-14=34bit. 所以VPN = 34.</p>
<p>physical page offset 和 virtual page offset必须是一样的, 也是14位, 接下来我们只要直到physical addresses, 减去offset就是PPN.</p>
<p>物理内存是16GB = $2^4*2^{30} = 2^{34}$ Byte 所以physical addresses 是34 Byte. 34-14 = 20, 所以 PPN = 20.</p>
<p><br></p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/control_flow_27.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如果发现没有, VP3存储在disk中而不是内存中, 此时就出发一个系统中断.</p>
<p><img src="/Blog/intro/comp_sys/control_flow_28.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_flow_29.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_flow_30.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_flow_31.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/control_flow_32.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>虚拟内存和内存分页也简化了程序的linking和loading</p>
<p>所有程序的起始位置都是一样的.(它们都感觉自己拥有对整个内存的控制)</p>
<p>text 在RISCV中就固定起始于<code>0x10000000</code></p>
<p><br></p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/virtual_eme.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/virtual_eme_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Page Fault 花费非常多的时间, 因为它访问了磁盘</p>
<p><br></p>
<p>MMU 访问了内存两次, 一次是为了拿到Page Table Entry , 一次是实际内存请求</p>
<ul>
<li>PET 可能和其他内存word一样被缓存到L1中<ul>
<li>但是他们可能和其他数据冲突, 进而丢失</li>
<li>hit in L1 cache still requires 1-3 cycles.</li>
</ul>
</li>
</ul>
<p>我们如何让它更快?</p>
<p>使用为分页提供另一个cache</p>
<p><br></p>
<h3 id="Translation-lookaside-Buffer-TLB"><a href="#Translation-lookaside-Buffer-TLB" class="headerlink" title="Translation lookaside Buffer(TLB)"></a>Translation lookaside Buffer(TLB)</h3><p>这个特殊的cache就叫做 Translation lookaside Buffer(TLB)</p>
<p><img src="/Blog/intro/comp_sys/virtual_eme_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Virtual Page Number 被拆分为 TLB tag 和 TLB index</p>
<p>返回PTE (physical page entry)</p>
<p><br></p>
<p>TLB Hit</p>
<p><img src="/Blog/intro/comp_sys/virtual_eme_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>TLB Miss</p>
<p><img src="/Blog/intro/comp_sys/virtual_eme_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如果TLB Miss被触发了, 是否需要访问磁盘</p>
<p>并不会, 因为Page table 本身不会离开内存, 因为page table 用于告诉program data是否在磁盘上. 不能再有一个table说page table是否在磁盘上, 这样就成了一个连锁问题</p>
<p><br></p>
<h4 id="Featching-data-on-a-Memory-Read"><a href="#Featching-data-on-a-Memory-Read" class="headerlink" title="Featching data on a Memory Read"></a>Featching data on a Memory Read</h4><p>整体流程</p>
<ol>
<li>检查 TLB<ul>
<li>输入: virtual page number, 输入 physical page number</li>
<li><strong>TLB Hit</strong>: Fetch translation, return PPN</li>
<li><strong>TLB Miss:</strong> Check page table(in memory)<ul>
<li>page Table Hit: 加载 page table entry 到 TLB</li>
<li>page Fault: Fetch page from disk to memory, update corresponding page table entry, then load entry into TLB.</li>
</ul>
</li>
</ul>
</li>
<li>Check cache<ul>
<li>输入: 物理地址, 输出: data</li>
<li><strong>Cache hit</strong>: 返回数据到processor</li>
<li><strong>Cache Miss:</strong> Fetch data value from memory, store it in cache, return it to processor.</li>
</ul>
</li>
</ol>
<p><img src="/Blog/intro/comp_sys/virtual_eme_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/virtual_eme_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>有一个问题是要思考的:</p>
<p>What needs to happen when the CPU(processor) switches processes?</p>
<ul>
<li>寄存器:<ul>
<li>存储旧的process的状态, 加载新的process的状态</li>
<li>Includeing the Page Table Base Register(PTBR)</li>
</ul>
</li>
<li>内存<ul>
<li>什么也不干. Pages for processes already exist in memory/disk and protected from each other</li>
</ul>
</li>
<li>TLB<ul>
<li><strong>Invalidate</strong> all entries in TLB – mapping is for old process’ VAs (清空TLB)</li>
</ul>
</li>
<li>Cache:<ul>
<li>Can leave alone because storing based on PAs – good for shared data</li>
</ul>
</li>
</ul>
<p><img src="/Blog/intro/comp_sys/virtual_eme_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Malloc"><a href="#Malloc" class="headerlink" title="Malloc"></a>Malloc</h2><h3 id="Memory-allocation"><a href="#Memory-allocation" class="headerlink" title="Memory allocation"></a>Memory allocation</h3><p>回顾一下数据存储的方式:</p>
<p>static global data:</p>
<ul>
<li>编译时固定大小.</li>
<li>entire lifetime of the program</li>
<li>portion is read-only</li>
</ul>
<p>stack-allocated data:</p>
<ul>
<li>临时变量</li>
<li>已知lifetime, 从进入 function 到 return</li>
</ul>
<p>Dynamic(heap) data</p>
<ul>
<li>size 只有在运行时才知道.</li>
<li>lifetime 也只有在运行时才知道</li>
</ul>
<p><br></p>
<h3 id="Performance-Goals"><a href="#Performance-Goals" class="headerlink" title="Performance Goals"></a>Performance Goals</h3><p>目标: Given some sequence of <em>melloc</em> and <em>free</em> requests $R_0,R_1,\cdots$ 最大化 <strong>吞吐量(throughput)</strong> and <strong>peak memory 利用率utilization</strong></p>
<p><br></p>
<h4 id="吞吐量-throughput"><a href="#吞吐量-throughput" class="headerlink" title="吞吐量(throughput)"></a>吞吐量(throughput)</h4><p>单位时间内完成的请求数量.</p>
<p>例如: 如果5000 malloc calls and 5000 free calls complete in 10 seconds. 那么吞吐量就是1000 operations/second</p>
<p><br></p>
<h4 id="Aggregate-payload"><a href="#Aggregate-payload" class="headerlink" title="Aggregate payload"></a>Aggregate payload</h4><p>定义: <strong>Aggregate payload</strong> $P_k$</p>
<p><code>malloc(p)</code> results in a block with a <strong>payload</strong> of <strong>p</strong> bytes</p>
<p>例如当malloc(40), 将会创建40+$\Delta$ 的空间, 因为需要额外开辟一段空间管理这40byte. 然而这就造成了浪费</p>
<p>After request $R_k$ has completed the <strong>aggregate payload</strong> $P_k$ is the sum of currently allocated payloads.</p>
<p>aggregate payload 是在经过一系列malloc free后 所有 payload 的和</p>
<p><br></p>
<h4 id="Current-Heap"><a href="#Current-Heap" class="headerlink" title="Current Heap"></a>Current Heap</h4><p>定义: Current Heap size $H_k$</p>
<p>假设 $H_k$ is monotonically non-decreasing</p>
<ul>
<li>allocator can increase size of heap using <code>sbrk</code></li>
</ul>
<p><br></p>
<h4 id="Peak-Memory-Utilization"><a href="#Peak-Memory-Utilization" class="headerlink" title="Peak Memory Utilization"></a>Peak Memory Utilization</h4><p>定义 $U<em>k=\max</em>{i\le k}P_i / H_k$ after k+1 request</p>
<p>Goal: maximize utilization for a sequence of request.</p>
<p><br></p>
<h4 id="Fragmentation"><a href="#Fragmentation" class="headerlink" title="Fragmentation"></a>Fragmentation</h4><p>Poor memory utilization is caused by <strong>fragmentation</strong></p>
<p>Sections of memory are not used to store anything useful, but cannot stisfy allocation request.</p>
<p>Two types: <strong>internal</strong> and <strong>external</strong></p>
<p><br></p>
<p>Fragmentation in structs</p>
<ul>
<li>Internal fragmentation was wasted space <strong>inside</strong> of the struct(between fields) due to alignment</li>
<li>External fragmentation was wasted space <strong>between</strong> struct instances (e.g. in an array) due to alignment.</li>
</ul>
<p><img src="/Blog/intro/comp_sys/fragmentation.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>举个例子:</p>
<p><img src="/Blog/intro/comp_sys/fragmentation_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如果我们此时申请48byte的空间. 也就是6个方块, 虽然我们现在有48byte的空间, 但他们不是连续的, 所以malloc会失败.</p>
<p><br></p>
<h3 id="实现allocator的难点"><a href="#实现allocator的难点" class="headerlink" title="实现allocator的难点"></a>实现allocator的难点</h3><p>如果要实现一个allocator, 有哪些难点?</p>
<ol>
<li>对于给定pointer, 我们怎么知道要free多少内存空间? <code>free(p)</code></li>
<li>如何跟踪free blocks?</li>
<li>如何选择要allocate的内存block (当有多个符合条件的内存块时)</li>
<li>如果我们开辟的结构比free block的大小小的时候, 我们应该对那些多于的空间做些什么?</li>
<li>How do we reinsert a freed block into the heap?</li>
</ol>
<p><br></p>
<h4 id="Knowing-How-Much-to-Free"><a href="#Knowing-How-Much-to-Free" class="headerlink" title="Knowing How Much to Free"></a>Knowing How Much to Free</h4><p>standard method:</p>
<p>keep the length of a block in the word preceding the data</p>
<ul>
<li>This word is often called the <strong>header field</strong> or <strong>header</strong></li>
<li>requires an extra word for every allocated.</li>
</ul>
<p>对所有allocated block, 需要一个额外的word</p>
<p><img src="/Blog/intro/comp_sys/fragmentation_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="Keep-Track-of-Free-Blocks"><a href="#Keep-Track-of-Free-Blocks" class="headerlink" title="Keep Track of Free Blocks"></a>Keep Track of Free Blocks</h4><p><img src="/Blog/intro/comp_sys/fragmentation_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="Implicit-Free-Lists"><a href="#Implicit-Free-Lists" class="headerlink" title="Implicit Free Lists"></a>Implicit Free Lists</h4><p>对于每个block 我们需要: size, is-allocated?</p>
<p>可以用两个word来存储, 但是这样有点浪费.</p>
<p>一个技巧是: 如果blocks是对齐的, 一些 low-order bits of size are always 0.</p>
<p>例如8byte对齐, 也就是说值是8的倍数, 最后3位就一定是0.</p>
<p>因此可以用最低位来代表 allocated/free flag( 只要 K &gt; 1)</p>
<p>因此当读取size时, 必须记得使用mask</p>
<p><img src="/Blog/intro/comp_sys/fragmentation_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br> example:</p>
<p><img src="/Blog/intro/comp_sys/fragmentation_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/fragmentation_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/fragmentation_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h5 id="Allocating-in-a-Free-Block"><a href="#Allocating-in-a-Free-Block" class="headerlink" title="Allocating in a Free Block"></a>Allocating in a Free Block</h5><p>如果当free Block的空间比allocate的空间大的时候, 要对free block进行拆分</p>
<p><img src="/Blog/intro/comp_sys/fragmentation_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h5 id="Freeing-a-block"><a href="#Freeing-a-block" class="headerlink" title="Freeing a block"></a>Freeing a block</h5><p><img src="/Blog/intro/comp_sys/fragmentation_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时我们有一个32的free block, 一个16的free block. 理论上来说是可以开辟49的空间的, 但是实际却开辟不了</p>
<p>所以我们要把两个block连起来.</p>
<p><img src="/Blog/intro/comp_sys/fragmentation_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>然而这里有一个问题, 如果前一个block也是free block, 如何和前一个block相连?</p>
<p>就是用双向链表, 空间换时间, 添加一个footer. header == footer.</p>
<p><img src="/Blog/intro/comp_sys/fragmentation_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时就可以处理以下这4种情况</p>
<p><img src="/Blog/intro/comp_sys/fragmentation_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h4 id="Explicit-free-list"><a href="#Explicit-free-list" class="headerlink" title="Explicit free list"></a>Explicit free list</h4><p><img src="/Blog/intro/comp_sys/fragmentation_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/fragmentation_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时free block的结构就有所不同了.</p>
<p> next 和 prev 是pointer, 可以指向heap的任何位置</p>
<p><img src="/Blog/intro/comp_sys/fragmentation_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>为了让这个list能循环, 要把最后一个节点指向第一个节点, 第一个节点指向最后一个节点</p>
<p><br></p>
<p>然而虽然这是一个双向链表. 但是它可以以任意顺序排列:</p>
<p><img src="/Blog/intro/comp_sys/fragmentation_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/fragmentation_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如果我们把一个block完全分配出去:</p>
<p><img src="/Blog/intro/comp_sys/fragmentation_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h5 id="Freeing-With-Explicit-Free-List"><a href="#Freeing-With-Explicit-Free-List" class="headerlink" title="Freeing With Explicit Free List"></a>Freeing With Explicit Free List</h5><p>Insertion Policy: 在free list 中, 应该把新的free block 放在哪里?</p>
<ol>
<li>LIFO(last in first out) policy<ul>
<li>把free block放到free list的首位(head)</li>
<li>好处: 简单快速</li>
<li>坏处: studies suggest fragmentation is worse than the alternative</li>
</ul>
</li>
<li>Address-ordered policy<ul>
<li>把free block根据地址顺序插入到 list 中</li>
<li>$address(pre) &lt; address(cur) &lt; address(next)$</li>
<li>坏处: 需要线性的时间进行搜索插入位置</li>
<li>studies suggest fragmentation is better than the alternative</li>
</ul>
</li>
</ol>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/fragmentation_19.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/fragmentation_20.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/fragmentation_21.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/fragmentation_22.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>由于这是一个循环列表, 我们一定要记得boundary tag.</p>
<p><br></p>
<h4 id="Segregated-Free-list"><a href="#Segregated-Free-list" class="headerlink" title="Segregated Free list"></a>Segregated Free list</h4><p><img src="/Blog/intro/comp_sys/fragmentation_23.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/fragmentation_24.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/fragmentation_25.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/fragmentation_26.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="数理逻辑-Digital-logic"><a href="#数理逻辑-Digital-logic" class="headerlink" title="数理逻辑 Digital logic"></a>数理逻辑 Digital logic</h2><h3 id="Synchronous-Digital-Systems-SDS"><a href="#Synchronous-Digital-Systems-SDS" class="headerlink" title="Synchronous Digital Systems (SDS)"></a>Synchronous Digital Systems (SDS)</h3><p>Synchronous:</p>
<ul>
<li><p>所有操作都是由central clock进行协调.</p>
<p>‒“Heartbeat” of the system! (processor frequency)</p>
</li>
</ul>
<p>Digital:</p>
<ul>
<li><p>Represent all values with two discrete values</p>
</li>
<li><p>Electrical signals are treated as 1’s and 0’s</p>
<p>‒1 and 0 are complements of each other</p>
</li>
<li><p>High/Low voltage for True/False, 1/0</p>
<p>通常我们讨论1千兆赫的处理器, 说的就是就是 heartbeat 的速率, 每秒1千兆赫</p>
</li>
</ul>
<p><br></p>
<p>Digital Systems 有两种基本的电路</p>
<ol>
<li>Combinational Logic (CL)<ul>
<li>Output is a function of the inputs only, not the history of its execution</li>
<li>e.g. circuits to add A, B (ALUs)</li>
</ul>
</li>
<li>Sequential Logic (SL)<ul>
<li>Circuit that “remember” or store information</li>
<li>e.g. memory and registers</li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h3><p><img src="/Blog/intro/comp_sys/digital_logic.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/digital_logic_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/digital_logic_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h3><p><img src="/Blog/intro/comp_sys/digital_logic_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>和离散的符号稍微有些区别: and 用 $\cdot$ , or 用 +</p>
<p><img src="/Blog/intro/comp_sys/digital_logic_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/digital_logic_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<ul>
<li><p><strong>Recall:</strong> Everything we are dealing with is just an abstraction of transistors and wires</p>
<ul>
<li>Inputs propagating to the outputs are voltage signals passing through transistor networks</li>
<li>There is always some <em>delay</em> before a CL’s output updates to reflect the inputs</li>
</ul>
</li>
<li><p>Simpler Boolean expressions ↔ smaller transistor networks ↔ smaller circuit delays ↔ faster hardware</p>
</li>
</ul>
<p><br></p>
<h3 id="多路复用器-MUX"><a href="#多路复用器-MUX" class="headerlink" title="多路复用器 MUX"></a>多路复用器 MUX</h3><p>Multiplexor</p>
<p>程序有时需要if-else的执行方式, 此时就用多路复用器</p>
<p><img src="/Blog/intro/comp_sys/digital_logic_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>s=0时, C=A, s=1 时, C=B.</p>
<p><img src="/Blog/intro/comp_sys/digital_logic_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/digital_logic_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/digital_logic_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Accumulatior"><a href="#Accumulatior" class="headerlink" title="Accumulatior"></a>Accumulatior</h3><p><img src="/Blog/intro/comp_sys/digital_logic_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/digital_logic_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/digital_logic_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h3><p><img src="/Blog/intro/comp_sys/digital_logic_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p><img src="/Blog/intro/comp_sys/digital_logic_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>1GHz描述的就是这个Clock period</p>
<p><br></p>
<blockquote>
<ul>
<li><p>Clock: steady square wave that synchronizes system</p>
</li>
<li><p>Register: several bits of state that samples on rising edge of Clock (positive edge-triggered); also has RESET</p>
</li>
<li><p>Setup Time: when input must be stable <em>before</em> Clock trigger</p>
</li>
<li><p>Hold Time: when input must be stable <em>after</em> Clock trigger</p>
</li>
<li><p>Clock-to-Q Delay: how long it takes output to change from Clock trigger</p>
</li>
</ul>
</blockquote>
<p><img src="/Blog/intro/comp_sys/digital_logic_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/digital_logic_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/digital_logic_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/digital_logic_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h3><p>Functional Units</p>
<p>Functional Units 是processor在运行程序时执行计算的一部分</p>
<ul>
<li>Arithmetic Logic Unit(ALUs)</li>
<li>Floating Point Unit</li>
<li>Load/Store Unit</li>
</ul>
<p><img src="/Blog/intro/comp_sys/alu.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/alu_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>1bit adder</p>
<p><img src="/Blog/intro/comp_sys/alu_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如果只有一个bit, 那么add 操作和 xor是非常相似的</p>
<p><img src="/Blog/intro/comp_sys/alu_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/alu_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>n bit adder</p>
<p><img src="/Blog/intro/comp_sys/alu_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/alu_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/alu_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>Central processing Unit(CPU) 主要由两个部分组成:</p>
<ul>
<li><p><strong>Datapath</strong>: contains the hardware necessary to perform operations required by the processor</p>
<ul>
<li>Reacts to what the controller tells it! (ie. “I was told to do an add, so I”ll feed these arguments through an adder)</li>
</ul>
</li>
<li><p><strong>Control</strong>: decides what each piece of the datapath should do</p>
<ul>
<li><p>What operation am I performing? Do I need to get info from memory? Should I write to a register? Which register?</p>
</li>
<li><p>Has to make decisions based on the input instruction only!</p>
</li>
</ul>
</li>
</ul>
<p><br></p>
<p>一条二进制指令<code>0101010111....</code></p>
<p>会先发送给 Control, 由它分析这条指令的类型, 应由哪个Datapath进行处理. 之后发给对应的Datapath.</p>
<p><br></p>
<h3 id="如何设计一个Datapath"><a href="#如何设计一个Datapath" class="headerlink" title="如何设计一个Datapath?"></a>如何设计一个Datapath?</h3><p>我们有6种不同的指令类型: R, I, S, SB, U, UI</p>
<p><br></p>
<h4 id="如果运行R-type指令"><a href="#如果运行R-type指令" class="headerlink" title="如果运行R-type指令"></a>如果运行R-type指令</h4><p>假设要运行一个R-type的指令要进行哪些步骤?</p>
<ol>
<li><p>获得指令</p>
<p><code>add t0 t2 t3</code></p>
</li>
<li><p>解析指令的 fields (rd, rs1, rs2, operation…)</p>
<p><code>rd=t0, rs1=t2, rs3=t3</code></p>
</li>
<li><p>通过解析的结果读取数据</p>
<p><code>R[t2], R[t3]</code></p>
</li>
<li><p>进行运算</p>
<p><code>R[t2]+R[t3]</code></p>
</li>
<li><p>写入destination register</p>
<p><code>R[t0] = R[t2] + R[t3]</code></p>
</li>
</ol>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/datapath.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="如果运行I-type指令"><a href="#如果运行I-type指令" class="headerlink" title="如果运行I-type指令"></a>如果运行I-type指令</h4><p>如果改为执行一个I-type的指令?</p>
<ul>
<li><p>A: Get the instruction </p>
</li>
<li><p>B: Parse instruction fields (rd, rs1, rs2)</p>
<ul>
<li>此时要解析 immediate</li>
</ul>
</li>
<li><p>C: Read data based on parsed operands</p>
</li>
<li><p>D: Perform operation</p>
</li>
<li><p>E: Write result to our destination register</p>
</li>
</ul>
<p><img src="/Blog/intro/comp_sys/datapath_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>通过添加 imm gen 以及多路复用器来让这个系统同时支持 add 和 addi</p>
<p><img src="/Blog/intro/comp_sys/datapath_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>然而 I-type 还有 lw 这些操 作memory 的指令</p>
<p><code>R[rd]=Memory[R[rs1] + IMM]</code></p>
<p><img src="/Blog/intro/comp_sys/datapath_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Memory[] 这个怎么表示?</p>
<p>我们增加一个<code>DMEM</code>模块, 它接受一个address返回data</p>
<p><img src="/Blog/intro/comp_sys/datapath_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<blockquote>
<p><img src="/Blog/intro/comp_sys/datapath_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
</blockquote>
<p><br></p>
<p>对于load指令, 我们有lw, lh, lb.</p>
<p><img src="/Blog/intro/comp_sys/datapath_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>而 func 3 就是用来控制具体使用那种load的</p>
<p><br></p>
<p><br></p>
<h4 id="如果运行S-type指令"><a href="#如果运行S-type指令" class="headerlink" title="如果运行S-type指令"></a>如果运行S-type指令</h4><p><img src="/Blog/intro/comp_sys/datapath_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>S-type 和 I-type 的imm值的区别只有最后5位, 因此只需要对最后5位通过多路复用器进行一次选择. 如果是I就取得$[20:25]$位的元素, 如果是R就选择$[7:12]$位置的元素</p>
<p><br></p>
<p>Branch 和 Store format 差不多</p>
<p><img src="/Blog/intro/comp_sys/datapath_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_19.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h4 id="I-format-Jalr-指令"><a href="#I-format-Jalr-指令" class="headerlink" title="I-format Jalr 指令"></a>I-format Jalr 指令</h4><p><img src="/Blog/intro/comp_sys/datapath_20.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_24.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_21.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_22.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_23.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h4 id="“Upper-Immediate”-instruction"><a href="#“Upper-Immediate”-instruction" class="headerlink" title="“Upper Immediate” instruction"></a>“Upper Immediate” instruction</h4><p><img src="/Blog/intro/comp_sys/datapath_25.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_26.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_27.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_28.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/datapath_29.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Control-Signals"><a href="#Control-Signals" class="headerlink" title="Control Signals"></a>Control Signals</h3><p>设计一个 Control Signal 有几个问题要思考:</p>
<ul>
<li>Control siganl 对于所有指令(I, R, S, SB…)是否都一样, If so, can you use a combination of opcode/func3/func7 to encode the value.</li>
<li>control signal 是否 dependent on other controls?<ul>
<li>例如PCSel, BrEq, BrLT</li>
</ul>
</li>
<li>Does the value of this control signal alter the execution of the instruction.<ul>
<li>Some cases: yes (MemRW)</li>
<li>Some cases: No (ImmSel in R-type inst)</li>
</ul>
</li>
</ul>
<p><br></p>
<p>设计PCSel</p>
<p>当PCSel = 0, <code>PC = PC+4</code> PCSel=1, <code>PC=ALUout</code></p>
<p>我们怎么知道一条指令是 Branch 指令</p>
<p><img src="/Blog/intro/comp_sys/pcsel.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<ul>
<li><p>Look at that! they all have the same opcode! We should also check to make sure no other instructions have the same one!</p>
</li>
<li><p>spoiler: they don’t, but you should check!</p>
</li>
</ul>
<p><img src="/Blog/intro/comp_sys/pcsel_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>如果 opcode == 63, 输出1, 反之输出0</p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/pcsel_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/pcsel_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/pcsel_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/pcsel_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/pcsel_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/pcsel_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/pcsel_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/pcsel_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/pcsel_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/pcsel_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/pcsel_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/pcsel_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/pcsel_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/pcsel_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/pcsel_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/pcsel_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>当IF执行完之后(200ps), IF在剩余指令执行完之前没有干任何事.</p>
<p>这就造成资源浪费.  那么如何提高性能?</p>
<p><br></p>
<p><br></p>
<h4 id="Processor-Performance"><a href="#Processor-Performance" class="headerlink" title="Processor Performance"></a>Processor Performance</h4><p><img src="/Blog/intro/comp_sys/control.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/control_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>运行一条指令需要1000ps, 但是运行3条指令只需要1400ps</p>
<p>而如果一条指令一条指令运行, 每条指令要800ps, 3条指令就是2400ps</p>
<p>使用pipline, 第一个指令运行时间会长一些, 但之后的指令速度会很快</p>
<p><img src="/Blog/intro/comp_sys/control_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/control_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Instruction-Level-Parallelism-ILP"><a href="#Instruction-Level-Parallelism-ILP" class="headerlink" title="Instruction Level Parallelism (ILP)"></a>Instruction Level Parallelism (ILP)</h3><ul>
<li><p>Pipelining allows us to execute parts of multiple instructions at the same time using the same hardware!</p>
<ul>
<li>This is known as <strong>instruction level parallelism</strong></li>
</ul>
</li>
<li><p>Later<strong>:</strong> Other types of parallelism</p>
<ul>
<li>DLP: same operation on lots of data (SIMD)</li>
<li>TLP: executing multiple threads “simultaneously” (OpenMP)</li>
</ul>
</li>
</ul>
<p><img src="/Blog/intro/comp_sys/control_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/control_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Piplining-Hazard"><a href="#Piplining-Hazard" class="headerlink" title="Piplining Hazard"></a>Piplining Hazard</h3><p>A <em>hazard</em> is a situation that prevents starting the next instruction in the next clock cycle</p>
<ol>
<li><p><strong>Structural hazard</strong></p>
<ul>
<li>A required resource is busy<br> (e.g. needed in multiple stages)</li>
</ul>
</li>
<li><p><strong>Data hazard</strong></p>
<ul>
<li>Data dependency between instructions</li>
<li>Need to wait for previous instruction to complete its data write</li>
</ul>
</li>
<li><p><strong>Control hazard</strong></p>
<ul>
<li>Flow of execution depends on previous instruction</li>
</ul>
</li>
</ol>
<p><br></p>
<p><br></p>
<h4 id="Structural-Hazard"><a href="#Structural-Hazard" class="headerlink" title="Structural Hazard"></a>Structural Hazard</h4><p>问题: 当pipline中两个以上的指令竞争同一块physical resource的访问时.</p>
<p>solution1: Instructions take turns using resource, some instructions have to stall (wait)</p>
<p>solution2: Add more hardware to machine</p>
<p><strong>Can always solve a structural hazard by adding more hardware</strong></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>load 指令的第5个cycle会把数据写入寄存器</p>
<p>然而sub指令也在此时访问了寄存器</p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h4 id="Data-Hazards"><a href="#Data-Hazards" class="headerlink" title="Data Hazards"></a>Data Hazards</h4><p>思考下面的指令</p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>然而在pipeline中, 一条指令要5个cycle才能执行完毕, 在执行完毕之前, s0 是没有被更新的. 而在s0更新之前, 是不能读取s0的.</p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>因此所有指令读取s0必须在第一条指令写入s0之后</p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>Stall reduce performance</p>
<ul>
<li>decrease throughput of “valid” or useful instructions</li>
<li>Can also be seen as increasing the latency of our stalled instruction</li>
</ul>
<p>但是为了得到正确的值, stall是必要的</p>
<p>Compiler可以arrange code来减少hazard and stalls.</p>
<p>然而这也需要 pipeline structure 和 instruction inseractions 的知识</p>
<p>另一种方法是添加额外的物理线路, 当前一条指令计算出结果(还没有执行完成/写入)就通过这条线图传递到下一条指令.</p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>当两条相邻指令depend on each other, 在这两条指令中间要有一个load delay slot, <code>nop</code>, 如果不手动写nop, 编译器会自动插入nop.</p>
<p>有时候重新组织代码顺序可以提高性能, 就不同nop了</p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h4 id="Control-Hazard"><a href="#Control-Hazard" class="headerlink" title="Control Hazard"></a>Control Hazard</h4><p>Branch 语句(beq, bne..) 决定 flow of control.</p>
<p>也就是说下一条指令取决于branch的结果</p>
<p>Pipline can’t always fetch correct instruction</p>
<p>解决办法就是 <strong>stall or flush</strong> on branch until we have the new PC value</p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>可以看到只有指令3会正确执行, 也就是跳过了两条指令</p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_19.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_20.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_21.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_22.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_23.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/structural_hazard_24.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p><br></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="CPU-与-Threads"><a href="#CPU-与-Threads" class="headerlink" title="CPU 与 Threads"></a>CPU 与 Threads</h2><p>每个核(core)有多个Thread</p>
<p><img src="/Blog/intro/comp_sys/cpu.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>例如这里对于每个core有两个thread, 在操作系统的视角就是有4个CPU, 但只有2个物理core.</p>
<p><img src="/Blog/intro/comp_sys/cpu_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>Memory slots是放内存条的地方, socket是放cpu的地方. 每个socket对应一组Memory slots.</p>
<p><img src="/Blog/intro/comp_sys/cpu_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>通常一个 processor 有 4-32 个 core</p>
<p>一个Mainstream database servers 一般有 2-4 sockets</p>
<p><br></p>
<p><br></p>
<h3 id="Non-Uniform-Memory-Access-NUMA"><a href="#Non-Uniform-Memory-Access-NUMA" class="headerlink" title="Non-Uniform Memory Access (NUMA)"></a>Non-Uniform Memory Access (NUMA)</h3><p><img src="/Blog/intro/comp_sys/cpu_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>处理器之间是相互连接的</p>
<p>处理器和内存也是相互连接的</p>
<p>而处理器访问自己对应连接的内存的速度是最快的, 访问其他处理器的内存时会随着距离变慢. 这个叫做 “<strong>NUMA effect</strong>“</p>
<p>可以使用 <code>numactl -H</code> 查看cpu的线程数, 以及对应node的内存大小</p>
<p><br></p>
<p><br></p>
<h2 id="计算机的主要组成部分"><a href="#计算机的主要组成部分" class="headerlink" title="计算机的主要组成部分"></a>计算机的主要组成部分</h2><h3 id="Main-memory"><a href="#Main-memory" class="headerlink" title="Main memory"></a>Main memory</h3><p>也叫做DRAM: dynamic rando access memory<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8">wiki</a></p>
<p>它是因此它属于一种易失性存储器（volatile memory）设备, 如果断电会丢失数据</p>
<p>系统可能也有小量的 non-volatile RAM 用来存储基本信息</p>
<ul>
<li>Bootstrap loader</li>
<li>BIOS (Basic input output system)</li>
</ul>
<p><br></p>
<h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><p>permanent home of data</p>
<p>大体有两种</p>
<ul>
<li>Hard disk</li>
<li>SSD (solid state drive)</li>
</ul>
<p><br></p>
<h4 id="Hard-Disk"><a href="#Hard-Disk" class="headerlink" title="Hard Disk"></a>Hard Disk</h4><p>过去10年主要的持久存储方式</p>
<p>由多个sectors组成, 每个sector有 512 byte block</p>
<p>可以看作是一个 array of sectors</p>
<p><img src="/Blog/intro/comp_sys/sectors.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>对一单个sector进行访问是具备原子性的. 要么全部写入要么不写 </p>
<p>然而对多个sector进行写入时可能会出现这种情况: 第一个sector被写入, 第二个sector没有, 而第三个sector被写入(torn writes)</p>
<p><br></p>
<h4 id="NAND-Flash-memory"><a href="#NAND-Flash-memory" class="headerlink" title="NAND Flash memory"></a>NAND Flash memory</h4><p>Basic building block: floating gate transistors(cells)</p>
<ul>
<li>Data stored in cells</li>
<li>Number of bits per cell determined by voltage levels</li>
</ul>
<p>Flash memory types:</p>
<ul>
<li>Single-level cell (SLC): 1 bit/cell (1 threshold voltage)</li>
<li>Multi-level cell (MLC): 2 bit/cell (3 threshold voltages)</li>
<li>More recently: TLC and QLC</li>
</ul>
<p>Organized in blocks and pages</p>
<ul>
<li><strong>can read/write at page level, modification must erase block</strong></li>
</ul>
<p>Fixed erase cycles</p>
<ul>
<li>SLC best, MLC worse, TLC even worse, QLC worst</li>
</ul>
<p><br></p>
<p>对于程序员来说 Hard disk 和 SSD 的接口是一样的, 所以不同太在意</p>
<p>因此对于SSD来说要使用 Flash Translation Layer(FTL) 来把Block/page 映射为sector来统一操作</p>
<p><img src="/Blog/intro/comp_sys/sectors_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/sectors_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/sectors_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>一些查看计算机信息的指令</p>
<p><code>df</code> Storage usage stats</p>
<p><code>mount</code> Mount existing file system for access</p>
<p><code>iostat</code>: show storage I/O speeds</p>
<p><code>free</code>: show memory usage</p>
<p><code>hdparm/sdparm:</code> Show I/O device stats and parameters.</p>
<p><br></p>
<p><br></p>
<h2 id="CPU-Device-Interactions"><a href="#CPU-Device-Interactions" class="headerlink" title="CPU-Device Interactions"></a>CPU-Device Interactions</h2><p>每一个device 都有它自己的controller</p>
<p>相当于一个小的电脑: 例如SSD 有ARM处理器以及RAM</p>
<p><br></p>
<p>CPU 和 device controllers 通过 common bus</p>
<p>CPU 通过main memory 向 device 传输/接收数据</p>
<p><br></p>
<p>每一个 device 都被 device driver 所管理,</p>
<p>device driver 是:</p>
<ul>
<li>Software to use the controller</li>
<li>Provides a uniform interface to the device for OS</li>
<li>Specific to hardware and the OS using the device</li>
</ul>
<p>CPU 和 其他 device 的 controller 可以同时工作 互不影响</p>
<p><br></p>
<p><br></p>
<p><strong>Input/Output Example</strong></p>
<p>从键盘读取一个字符</p>
<ol>
<li>cpu 告诉 键盘的controller 说它要读取字符<ul>
<li>by loading registers in the device, using device driver</li>
</ul>
</li>
<li>键盘controller就只要 它收到了一个”read” 的请求</li>
<li>键盘收到字符后就把它放入local buffer中</li>
</ol>
<p>现在键盘的controller就需要让CPU知道读取操作结束了</p>
<p>这是通过系统中断进行的.</p>
<p><br></p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>Signals sent by hardware devices to the CPU</p>
<ul>
<li>一个主流的方法是用硬件进行系统中断</li>
<li>当CPU收到信号, 它就会停止当前的工作来处理中断请求 通过 interrupt service routine(ISR)<ul>
<li>Aka interrupt handlers</li>
<li>Callback function triggered when an interrupt is signaled</li>
</ul>
</li>
<li>ISR执行结束后, CPU在继续执行之前的工作</li>
<li>相当于异步操作</li>
</ul>
<p><br></p>
<p>如何找到对应的 ISR</p>
<p>我们希望interrupts 可以被快速处理, 同时系统可以支持多个interrupt </p>
<p>解决办法就是使用中断向量表(interrupt vector)</p>
<p><br></p>
<h3 id="Busy-Waiting"><a href="#Busy-Waiting" class="headerlink" title="Busy Waiting"></a>Busy Waiting</h3><p>另一种方法是 busy waiting</p>
<ol>
<li>CPU 向device controller 发送 I/O operations</li>
<li>Controller 处理请求, 返回结果</li>
<li>CPU 等待 I/O 操作结束在返回其他工作</li>
</ol>
<p><img src="/Blog/intro/comp_sys/interrupts.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Interrupt-Driven-I-O"><a href="#Interrupt-Driven-I-O" class="headerlink" title="Interrupt-Driven I/O"></a>Interrupt-Driven I/O</h3><p>总共有3步:</p>
<ol>
<li>数据从 device 传输到它的 local buffer</li>
<li>发送 interrupt 给 CPU 或 device</li>
<li>CPU 通过从device 的 local buffer中 拷贝数据到main memory来处理 interrupt </li>
</ol>
<p>如果少量数据的话这么做是可行的, 但high overhead for transferring a lot of data.</p>
<ul>
<li>many interrupts</li>
<li>many CPU involvement</li>
</ul>
<p><img src="/Blog/intro/comp_sys/interrupts_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Direct-Memory-Access-DMA"><a href="#Direct-Memory-Access-DMA" class="headerlink" title="Direct Memory Access (DMA)"></a>Direct Memory Access (DMA)</h3><p><strong>Transferring data without involving the CPU</strong></p>
<ul>
<li>Used for high-speed I/O devices able to transmit information at close to memory speeds.</li>
<li>Device transfers data from its local buffer directly to main memory<ul>
<li>Device gains access to memory</li>
<li><strong>No CPU involvement</strong></li>
</ul>
</li>
<li>Only one interrupt is generated data block/request</li>
</ul>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/interrupts_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Operating-System-Operations"><a href="#Operating-System-Operations" class="headerlink" title="Operating System Operations"></a>Operating System Operations</h2><ol>
<li><p>Bootstrapping using a bootstrap program</p>
<ul>
<li>simple code to initialize the system and load the kernel</li>
</ul>
</li>
<li><p>After the kernel is loaded, start system deamons</p>
<ul>
<li>Services provided outside of the kernel</li>
</ul>
</li>
<li><p>Run user programs</p>
</li>
</ol>
<p><br></p>
<p>操作系统的另一个主要的任务是manage process</p>
<p><br></p>
<p>我们希望让多个程序在cpu中执行</p>
<p>我们需要在不同的process之间进行交换, 此时就需要 一些 scheduling algorithms</p>
<ul>
<li>当一个process在等待IO时, 切换到另一个process继续执行(让cpu一直工作)</li>
</ul>
<p><br></p>
<p><br></p>
<h2 id="Multi-Mode-Operations"><a href="#Multi-Mode-Operations" class="headerlink" title="Multi Mode Operations"></a>Multi Mode Operations</h2><p>只有操作系统可以使用 privileged instructions</p>
<ul>
<li>Privileged instructions: operations that may cause harm<ul>
<li>例如: I/O control, timer management, interrupts</li>
</ul>
</li>
<li>User and kernel modes:<ul>
<li>User mode: Process executes on behalf of the user</li>
<li>Kernel mode: Process executes on behalf on the kernel </li>
</ul>
</li>
</ul>
<p><br></p>
<p>如果不在kernel mode, 可以让硬件发起一个中断</p>
<p>这会把系统切换成kernel mode</p>
<p>如何让用户对privileged instruction进行访问?</p>
<p>使用 System call</p>
<p><br></p>
<p>当使用System call时, 系统先会检查权限等一些东西, 如果一些都合法, 就会切换到kernel mode</p>
<p>系统执行system call在返回user mode</p>
<p><br></p>
<p><br></p>
<h2 id="Operating-System-Structures"><a href="#Operating-System-Structures" class="headerlink" title="Operating System Structures"></a>Operating System Structures</h2><p>我们如何设计像OS一个复杂的系统</p>
<ul>
<li>Monolithic</li>
<li>Layered</li>
<li>Microkernel</li>
<li>Modular</li>
<li>Hybrid</li>
</ul>
<p><br></p>
<h3 id="Monolithic-Structure"><a href="#Monolithic-Structure" class="headerlink" title="Monolithic Structure"></a>Monolithic Structure</h3><p>写很多c file,最后把他们一起编译成一个二进制文件</p>
<p><img src="/Blog/intro/comp_sys/kernel.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Linux 就是 monolithic kernel</p>
<p><br></p>
<p>优点:</p>
<p>性能高</p>
<ul>
<li>little overhead in system call interface</li>
<li>Communication within the kernel is fase</li>
</ul>
<p>缺点:</p>
<p>Difficult to implement &amp; maintain</p>
<ul>
<li>too much in one layer</li>
</ul>
<p><img src="/Blog/intro/comp_sys/kernel_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Layered-Structure"><a href="#Layered-Structure" class="headerlink" title="Layered Structure"></a>Layered Structure</h3><p>把OS 分成多层</p>
<p>每一层layer都只会使用下一层的layer提供的服务</p>
<p><img src="/Blog/intro/comp_sys/kernel_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>优点:</p>
<p>开发更简单, 更方便维护</p>
<p><br></p>
<p>缺点:</p>
<p>Less efficient:</p>
<ul>
<li>Each layer adds some overhead</li>
</ul>
<p>Tricky to define layers</p>
<p><br></p>
<h3 id="Microkernel-Structure"><a href="#Microkernel-Structure" class="headerlink" title="Microkernel Structure"></a>Microkernel Structure</h3><p><strong>Kernel provides minimal services; the rest in user space</strong></p>
<ul>
<li>Modules communicate using message passing</li>
</ul>
<p>优点:</p>
<ul>
<li>Easier to extend and port to new hardware architectures</li>
<li>More reliable and secure: most services are in user mode</li>
</ul>
<p>这也是linux很难支持新的原因. 每当要新增hardware, 都需要在kernel mode下device driver写作一个kernel module.</p>
<p>缺点: 性能降低</p>
<p><br></p>
<p>Microkernel Structure Example: Mach</p>
<p><img src="/Blog/intro/comp_sys/kernel_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Modular-Structure"><a href="#Modular-Structure" class="headerlink" title="Modular Structure"></a>Modular Structure</h3><p>Implement OS as separate components(modules)</p>
<ul>
<li>Core components in kernel module</li>
<li>Other modules loaded linked to kernel as needed<ul>
<li>no recompilation</li>
</ul>
</li>
<li>Each module has a well-defined interface<ul>
<li>modules talk to each other using interfaces</li>
</ul>
</li>
</ul>
<p>Most modern OSes (e.g. Linux) implement kernel modules</p>
<p><br></p>
<p>优点:</p>
<ul>
<li>易于维护</li>
<li>类似于layers但更稳定<ul>
<li>avoid the problem of defining layers</li>
</ul>
</li>
<li>类似与microkernel 但更高效<ul>
<li>modules can call others directly</li>
</ul>
</li>
</ul>
<p>缺点:</p>
<p>Modules are part of the kernel with <strong>full permission</strong></p>
<ul>
<li>Stability: buggy modules may cause the OS to crash</li>
<li>Security: a malicious module can compromise the whole system</li>
</ul>
<p><br></p>
<h3 id="Hybrid-Structures-Most-Current-OSes"><a href="#Hybrid-Structures-Most-Current-OSes" class="headerlink" title="Hybrid Structures: Most Current OSes"></a>Hybrid Structures: Most Current OSes</h3><p><img src="/Blog/intro/comp_sys/kernel_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="System-Boot"><a href="#System-Boot" class="headerlink" title="System Boot"></a>System Boot</h3><p>OS must be available to hardware to start it</p>
<p>On powered up the instruction register is loaded with a predefined memory location</p>
<p><br></p>
<p><br></p>
<h2 id="Processes-and-Threads"><a href="#Processes-and-Threads" class="headerlink" title="Processes and Threads"></a>Processes and Threads</h2><p><img src="/Blog/intro/comp_sys/process.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/process_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/process_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Linux 中的 PCB. processes 是以 linklist 存储</p>
<p><img src="/Blog/intro/comp_sys/process_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/process_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/process_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/process_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>processes 是由其他的 process创建的</p>
<p><img src="/Blog/intro/comp_sys/process_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>最初的process由OS来创建</p>
<p><br></p>
<p>这个创建方法在 linux中就是使用fork</p>
<p><img src="/Blog/intro/comp_sys/process_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/process_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<p>当process 执行完最后一句指令后会告诉OS delete it.(exit)</p>
<ul>
<li>process’ resources are de-allocated by OS</li>
<li>Output data from child to parent (via wait)</li>
</ul>
<p>Parent 可能终止子进程的执行(abort)</p>
<ul>
<li>Child has exceeded allocated resources</li>
<li><p>Task assigned to child is no longer required</p>
</li>
<li><p>if parent is exiting</p>
<ul>
<li>some operating system do not allow children to continue</li>
<li>Children of the children are terminated</li>
</ul>
</li>
</ul>
<p><br></p>
<p>僵尸进程 Zombie process:</p>
<ul>
<li>Process terminated but parent hasn’t called wait() yet </li>
<li>Return value held in memory</li>
</ul>
<p>孤儿进程 Orphan process:</p>
<ul>
<li>Process running but parent exited without calling wait()</li>
<li>Adoption (init/systemd process in Linux)</li>
</ul>
<p><br></p>
<p>Thread</p>
<p><img src="/Blog/intro/comp_sys/process_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/process_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/process_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h2 id="Multithreading-Models"><a href="#Multithreading-Models" class="headerlink" title="Multithreading Models"></a>Multithreading Models</h2><p>Mapping from user-level threads to kernel-level threads can be:</p>
<ul>
<li>many to one</li>
<li>one to one</li>
<li>many to many</li>
</ul>
<p><img src="/Blog/intro/comp_sys/process_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/process_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/process_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/process_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/process_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/process_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Threads-中-运行-Fork-函数的语义"><a href="#Threads-中-运行-Fork-函数的语义" class="headerlink" title="Threads 中 运行 Fork 函数的语义"></a>Threads 中 运行 Fork 函数的语义</h2><p>一个进程(process)有多个线程(Thread), 其中一个线程调用fork函数</p>
<p>Should <code>fork()</code> duplicate only the calling thread or all threads (entire process)?</p>
<ul>
<li>it depends:<ul>
<li>如果 <code>exec()</code> 在<code>fork</code>之后立即被调用 no need to duplicate all threads (they will be overwritten anyway)</li>
<li>Else, all thread should be duplicated</li>
</ul>
</li>
</ul>
<p><br></p>
<p><br></p>
<h2 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h2><p>signal 是 Unix 中用来notify a process that an event has occurred</p>
<p>有两种类型:</p>
<ol>
<li>Synchronous: delivered to the same process that performed the operation that caused the signal(e.g. illegal memory access)</li>
<li>Asynchronous: Signal generated by an external event, usually delivered to a different process (e.g. ctrl-c)</li>
</ol>
<p>Sequence:</p>
<ul>
<li>Signal is generated by an event (e.g. ctrl-c or packed arrived)</li>
<li>Signal is delivered to a process</li>
<li>Signal handle processes the signal(default by OS, or user-defined)</li>
</ul>
<p><img src="/Blog/intro/comp_sys/signal.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><code>SIGINT</code> 代表的就是 ctrl-c 产生的信号</p>
<p><br></p>
<p><br></p>
<p>那么下一个问题就是: Should OS deliver a signal to: all threads, one thread, or specific thread of a process?</p>
<p>It depends on the signal type</p>
<ul>
<li>Synchronous: a thread performed an operation that caused a signal to be generated(e.g. division by 0, illegal memory access)<ul>
<li>deliver signal to the thread</li>
</ul>
</li>
<li>Asynchronous: external event generated the signal (e.g. ctrl-c)<ul>
<li>deliver signal to all threads belonging to the process</li>
</ul>
</li>
</ul>
<p>Threads can choose to block signals</p>
<p><img src="/Blog/intro/comp_sys/signal_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/signal_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/signal_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/signal_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h2><p>为了让CPU一直工作, 我们keep multiple programs(processes) in memory</p>
<p><img src="/Blog/intro/comp_sys/signal_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>而如何设计调度算法来提高cpu利用率?</p>
<p><br></p>
<h3 id="Process-thread-Types"><a href="#Process-thread-Types" class="headerlink" title="Process(thread) Types"></a>Process(thread) Types</h3><p><img src="/Blog/intro/comp_sys/signal_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/signal_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>大部分的操作系统只有 CPU scheduler</p>
<p><br></p>
<h3 id="Scheduler-Types"><a href="#Scheduler-Types" class="headerlink" title="Scheduler Types"></a>Scheduler Types</h3><h4 id="Long-term-scheduler-aka-job-scheduler"><a href="#Long-term-scheduler-aka-job-scheduler" class="headerlink" title="Long-term scheduler(aka job scheduler)"></a>Long-term scheduler(aka job scheduler)</h4><ul>
<li>select which process should be brought into the ready queue</li>
<li>Controls the degree of multiprogramming<ul>
<li>how many process to keep in memory</li>
</ul>
</li>
<li>Invoked infrequently(seconds, minutes)<ul>
<li>can be slow</li>
</ul>
</li>
<li>Should maintain a ‘good mix’ of CPU-bound and I/O-bound jobs in the system</li>
</ul>
<p><br></p>
<h4 id="Short-term-scheduler-aka-CPU-scheduler"><a href="#Short-term-scheduler-aka-CPU-scheduler" class="headerlink" title="Short-term scheduler(aka CPU scheduler)"></a>Short-term scheduler(aka CPU scheduler)</h4><ul>
<li>Selects which process should be executed next and allocates CPU to it</li>
<li>Invoked very frequently (milliseconds)<ul>
<li>Must be fast</li>
</ul>
</li>
</ul>
<p><br></p>
<h4 id="Medium-term-scheduler"><a href="#Medium-term-scheduler" class="headerlink" title="Medium-term scheduler"></a>Medium-term scheduler</h4><ul>
<li>Swaps processes in and out of ready queue to enhance performance (i.e. maintain the good mix of job)</li>
</ul>
<p><br></p>
<h2 id="CPU-Scheduler"><a href="#CPU-Scheduler" class="headerlink" title="CPU Scheduler"></a>CPU Scheduler</h2><p>从ready queue中选择一个进程来在CPU上执行</p>
<p>核心就两个, “谁”在CPU上运行, 以及运行多长时间</p>
<ul>
<li>Scheduling can be <strong>non-preemptive</strong> or <strong>preemptive</strong></li>
</ul>
<p><br></p>
<p><strong>Non-preemptive:</strong></p>
<p>Once a process is allocated a CPU, it does not leave unless:</p>
<ul>
<li>it has to wait, e.g. for an I/O or for a child to terminate, or</li>
<li>it terminates</li>
</ul>
<p><br></p>
<p><strong>Preemptive:</strong></p>
<p>OS can force (preempt) a process from CPU at anytime</p>
<ul>
<li>Say, to allocate the CPU to another higher-priority process</li>
</ul>
<p><br></p>
<blockquote>
<p>Preemptive is more difficult to implement</p>
<p>It need to maintain consistency of data shared between processes and kernel data structures (e.g., I/O queues)</p>
<ul>
<li>Preemption while kernel is executing a syscall on behalf of a process (many OSs wait for syscall to finish)</li>
<li>May need hardware support (like timers)</li>
</ul>
</blockquote>
<p><br></p>
<h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><p>Dispatcher: 当scheduler选择接下来要执行的进程, dispatcher会allocate a CPU 给这个进程, which involves:</p>
<ul>
<li>Switching context</li>
<li>Switching to user mode</li>
<li>Jumping to the proper location(in the selected process) and (re)starting it</li>
</ul>
<p>Dispatch latency: time take for the dispatcher to stop one process and start another</p>
<p><br></p>
<p><br></p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>Scheduling Criteria(准则):</p>
<ul>
<li>最大化:<ul>
<li>CPU utilization - keep the CPU as busy as possible</li>
<li>Throughput - number of processes that complete their execution per time uint</li>
</ul>
</li>
<li>最小化<ul>
<li>Turnaround time - amount of time to execute a particular process (time from submission to termination)</li>
<li>Waiting time - amount of time a process has bean waiting in ready queue</li>
<li>Response time - amount of time it takes from when a request is submitted until the first response is preduced</li>
</ul>
</li>
</ul>
<h3 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a><strong>Algorithms</strong></h3><ul>
<li>First come, First Served</li>
<li>Shortest Job First (SJF)<ul>
<li>Approximate SJF</li>
<li>Shortest-Remaining-Time-First (SRTF)</li>
</ul>
</li>
<li>Priority</li>
<li>Round Robin</li>
<li>Multilevel Queue Scheduling</li>
<li>Multilevel Feedback Queue Scheduling</li>
</ul>
<blockquote>
<p>一个process可能有many CPU bursts, 但是下面的例子我们假设只有一个CPU</p>
</blockquote>
<p><br></p>
<h4 id="FCFS-First-come-First-served"><a href="#FCFS-First-come-First-served" class="headerlink" title="FCFS(First come, First served)"></a>FCFS(First come, First served)</h4><p><img src="/Blog/intro/comp_sys/scheduling_algorithm.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>burst time 就是 一个process执行所需要的时间</p>
<p>此时就是Non-preemptive scheduling</p>
<p>这个的waiting time取决于哪个进程先来. 如果以P2, P3, P1 这个顺序arrive的话, waiting time也会不同</p>
<p><img src="/Blog/intro/comp_sys/scheduling_algorithm_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这里我们没有考虑Dispatcher latency 和 scheduler latency</p>
<p><br></p>
<p>坏处</p>
<p><img src="/Blog/intro/comp_sys/scheduling_algorithm_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="SJF-Shortest-Job-First"><a href="#SJF-Shortest-Job-First" class="headerlink" title="SJF(Shortest-Job-First)"></a>SJF(Shortest-Job-First)</h4><p><img src="/Blog/intro/comp_sys/scheduling_algorithm_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>这个算法需要知道process的运行时间</p>
<p>当P1执行完成后, P2, P3, P4 就都在ready queue中了</p>
<p>我们发现P3有最小的运行时间, 所以接下来让P3执行</p>
<p>P3执行完成后, 由于P2和P4的执行时间一样, 所以选哪个都行</p>
<p>怎么看waiting time呢?  就是看每一个进程的到达时间和开始执行时间的间距就一这个进程的waiting time</p>
<p>依然这是non-preemptive</p>
<p><br></p>
<h4 id="Shortest-Remaining-Time"><a href="#Shortest-Remaining-Time" class="headerlink" title="Shortest-Remaining-Time"></a>Shortest-Remaining-Time</h4><p><img src="/Blog/intro/comp_sys/scheduling_algorithm_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时就是preemptive的算法</p>
<p>思想就是当一个process<strong>来到队列</strong>时, 就对当前任务进行一下暂停, 同时计算一下它剩余的预计要完成时间, 对于所有的process的剩余预计完成时间, 挑选最小的那个进行执行. 同理当<strong>一个任务完成时</strong>也这样执行一次.</p>
<p>这样就可以保证当前执行的任务是所有process中最快完成的</p>
<p><br></p>
<p><br></p>
<h4 id="Priority-Scheduling"><a href="#Priority-Scheduling" class="headerlink" title="Priority Scheduling"></a>Priority Scheduling</h4><p><strong>Schedule the process with the highest priority</strong></p>
<p>Priority: An integer associated with each process</p>
<ul>
<li>Priority can be based on many factors<ul>
<li>Time limits</li>
<li>Memory requirements</li>
<li>External factors<ul>
<li>e.g. system vs user jobs</li>
</ul>
</li>
</ul>
</li>
<li><p>Can be preemptive or non-preemptive</p>
</li>
<li><p>Vulnerable to starvation</p>
<ul>
<li>low priority processes may never execute</li>
<li>Possible solution: change priority dynamically<ul>
<li>Aging- increase the priority of a process as it waits</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>if priority is inverse of CPU burst length, then it becomes <strong>SJF</strong></p>
<p><br></p>
<h4 id="Round-Robin-RR-Scheduling"><a href="#Round-Robin-RR-Scheduling" class="headerlink" title="Round Robin(RR) Scheduling"></a>Round Robin(RR) Scheduling</h4><p><img src="/Blog/intro/comp_sys/scheduling_algorithm_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>随机为每个进程分配一些运行时间$q$, 当时间到了的时候就切换进程</p>
<p>If there are n processes in the ready queue</p>
<ul>
<li>Each process gets $1/n$ of  CPU time</li>
<li>Processes wait for at most $(n-1)q$ time units before executing</li>
</ul>
<p>Typically, higher average turnaround time than SJF, but better response time</p>
<p>如果 $q$ 非常大就会变成FCFS</p>
<p>如果 $q$ 非常小, High overhead due to many context switches</p>
<p><img src="/Blog/intro/comp_sys/scheduling_algorithm_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h4 id="Multilevel-Queue-Scheduling"><a href="#Multilevel-Queue-Scheduling" class="headerlink" title="Multilevel Queue Scheduling"></a>Multilevel Queue Scheduling</h4><p>本质是上述算法的结合</p>
<p><img src="/Blog/intro/comp_sys/scheduling_algorithm_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时我们有多个ready queue, 我们可以给每一个queue使用一个算法</p>
<p>一个进程可以在多个不同的queue中移动(动态改变priority)</p>
<p>思想: 当一个进程需要大量CPU时就把它挪到lower priority queue中</p>
<p>为此, 我们需要定义:</p>
<ol>
<li>number of queues</li>
<li>每一个queue的独调度算法</li>
<li>Method to move process up/down in queues</li>
<li>Start queue for each process</li>
</ol>
<p><img src="/Blog/intro/comp_sys/scheduling_algorithm_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Q1中的任务只有在Q0为空时才会执行</p>
<p>一个新的job会先放入Q0中, 得到8ms的运行时间, 如果没有运行完, 把它转移到Q1(<strong>当一个进程需要大量CPU时就把它挪到lower priority queue中</strong>)</p>
<p>因此: </p>
<p>Short processes are served faster -&gt; more responsive</p>
<p>Long processes will sink to the bottom (FCFS) (higher throughput)</p>
<p><br></p>
<h3 id="Multiple-Processor-Scheduling"><a href="#Multiple-Processor-Scheduling" class="headerlink" title="Multiple-Processor Scheduling"></a>Multiple-Processor Scheduling</h3><p>然而, 通常电脑是有多个CPU的, 多个hyper-thread</p>
<p>需要在其中多个处理器之间分配负载</p>
<ul>
<li>比单核的CPU调度更难</li>
</ul>
<p>如何divide load?</p>
<ul>
<li>Asymmetric multiprocessor<ul>
<li>One master processor does the scheduling for others</li>
</ul>
</li>
<li>Symmetric multiprocessor(SMP)<ul>
<li>Each processor runs its own scheduler</li>
<li>One ready queue for all processors or separate ready queue for each processor</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="SMP-Issues"><a href="#SMP-Issues" class="headerlink" title="SMP Issues"></a>SMP Issues</h3><p>Processor affinity:</p>
<ul>
<li><p>When a process runs on a processor, some data is brought in to that processor’s cache</p>
</li>
<li><p>Process migrates to another processor</p>
<ul>
<li>Cache of new processor has to be re-populated</li>
<li>Cache of old processor has to be invalidated</li>
<li>Performance penalty</li>
<li>Extra interconnect traffic (NUMA effect)</li>
</ul>
</li>
<li>Related tool: taskset<ul>
<li>Set processor affinity for a program (指定process在那个CPU上运行)</li>
</ul>
</li>
</ul>
<p><br></p>
<p>Load balancing:</p>
<p>确保负载在处理器之间平均分配</p>
<p>Balance load using:</p>
<ul>
<li><strong>Push migration</strong>: A specific task periodically checks load on all processors and evenly distributes it by moving tasks   </li>
<li><strong>Pull migration</strong>: Idle processor pulls a waiting task from a busy processor</li>
</ul>
<p>Tradeoff between load balancing and processor affinity</p>
<p><br></p>
<p><br></p>
<h3 id="Real-time-Scheduling"><a href="#Real-time-Scheduling" class="headerlink" title="Real-time Scheduling"></a>Real-time Scheduling</h3><p><strong>Hard-real time systems:</strong></p>
<ul>
<li>Task must be finished within a deadline.<ul>
<li>通常用于嵌入式系统, 例如飞机</li>
</ul>
</li>
<li>Need different types of schedulers to ensure deadlines are met.<ul>
<li>Rate monotonic, earliest deadline first (EDF)</li>
</ul>
</li>
</ul>
<p><strong>Soft-real time systems:</strong></p>
<ul>
<li>没有严格的deadline,but should be executed “quickly”<ul>
<li>Examples: multimedia systems, kernel tasks </li>
</ul>
</li>
<li>Priority based scheduling with preemption</li>
</ul>
<p><br></p>
<h2 id="Linux-Completely-Fair-Scheduler-CFS"><a href="#Linux-Completely-Fair-Scheduler-CFS" class="headerlink" title="Linux: Completely Fair Scheduler (CFS)"></a>Linux: Completely Fair Scheduler (CFS)</h2><p>Separate scheduling classes</p>
<ul>
<li><p>Real-time processes: higher priority (FIFO, RR)</p>
</li>
<li><p>Normal processes: lower priority (CFS)</p>
</li>
</ul>
<p>Each process gets a time portion based on its <strong>nice value</strong></p>
<ul>
<li>Nice value from -20 to +19 (lower nice = higher priority)</li>
</ul>
<p><img src="/Blog/intro/comp_sys/nice.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Virtual-run-time"><a href="#Virtual-run-time" class="headerlink" title="Virtual run time"></a>Virtual run time</h3><p>Used to automatically determine priority</p>
<p>Physical run time + decay</p>
<ul>
<li><p>Low priority processes have higher decay</p>
</li>
<li><p>Normal default priority yields virtual run time = actual run time</p>
</li>
</ul>
<p>优先级和虚拟运行时间成反比</p>
<p>Preemption is allowed</p>
<p><img src="/Blog/intro/comp_sys/nice_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Synchronization-Tools"><a href="#Synchronization-Tools" class="headerlink" title="Synchronization Tools"></a>Synchronization Tools</h2><p><strong>Processes/Threads may cooperate with each other</strong></p>
<p>因此需要一种方法来share data safely</p>
<p>有两种方法: Shared Memory, Message Passing</p>
<p><img src="/Blog/intro/comp_sys/share.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Shared Memory 的优缺点:</p>
<p>优点:</p>
<ul>
<li>快速(memory speed)</li>
<li>易于编程 (just regular memory)</li>
</ul>
<p>缺点:</p>
<ul>
<li>需要管理conflict (tricky for distributed systems and multi-threaded processes)</li>
</ul>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/share_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Message Passing 的优缺点</p>
<p>优点:</p>
<ul>
<li>没有冲突</li>
<li>易于交换消息，尤其是在分布式系统中</li>
</ul>
<p>缺点:</p>
<ul>
<li>high overload, 慢</li>
<li>prepare messages</li>
<li>Kernel involvement: sender $\to$ kernel $\to$ receiver</li>
<li>Several system calls</li>
</ul>
<p><br></p>
<h3 id="The-Producer-Consumer-problem"><a href="#The-Producer-Consumer-problem" class="headerlink" title="The Producer-Consumer problem"></a>The Producer-Consumer problem</h3><p>两个process (thread) 共享一块内存</p>
<p>其中一个向 buffer 中放入数据 (producer)</p>
<p>另一个从 buffer 中读取数据 (consumer)</p>
<p><img src="/Blog/intro/comp_sys/share_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/share_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/share_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/share_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>多进程(多线程)使用共享内存时, 可能会出现数据不一致的情况, 这取决于指令执行的顺序</p>
<p>如何处理这个问题?</p>
<ul>
<li>Mark code segment that manipulates shared data as critical section (CS)</li>
<li>If a process is executing the CS, no other processes can execute the CS</li>
</ul>
<p><img src="/Blog/intro/comp_sys/share_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>同一时间, 只有一个进程(线程)能访问critical section</p>
<p><br></p>
<p>然而如果我们要用上述方法, 有三个 requirements</p>
<ul>
<li>互斥(Mutual exclusion): 同一时间, 只有一个进程(线程)能访问critical section</li>
<li>Progress: Process/thread should eventually complete (i.e., make progress)</li>
<li>Bounded waiting: An upper bound must exist for the amount of time a thread/process waits to enter the CS (i.e., at most wait for a finite amount of time)</li>
</ul>
<p><br></p>
<p><br></p>
<p>其他的解决方案:</p>
<ul>
<li>On uniprocessor systems<ul>
<li>禁止在 CS 中运行 interrupts</li>
<li>Currently running code executes without preemption</li>
<li>缺点是CS的大小掌握在user手中, 如果非常大, 系统会长时间没有响应</li>
</ul>
</li>
</ul>
<p>还有其他更好的解决方案</p>
<p><br></p>
<p><br></p>
<h3 id="Perterson’s-solution"><a href="#Perterson’s-solution" class="headerlink" title="Perterson’s solution"></a>Perterson’s solution</h3><p>software solution, 不需要硬件支持</p>
<p>solution for <strong>2 processes</strong></p>
<p>假设load和store指令是atomic</p>
<ul>
<li>May not always work on modern computers due to reordering</li>
</ul>
<p>需要 2 shared data items</p>
<ul>
<li>One integer (<code>turn</code>)</li>
<li>One boolean array (<code>flag[2]</code>)</li>
</ul>
<p><img src="/Blog/intro/comp_sys/perterson.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Hardware-Instructions-for-Synchronization"><a href="#Hardware-Instructions-for-Synchronization" class="headerlink" title="Hardware Instructions for Synchronization"></a>Hardware Instructions for Synchronization</h3><p>现代机器提供特殊的<strong>atomic instructions</strong>, 使得软件层的synchronization更方便</p>
<p>Example:</p>
<ul>
<li><strong>Atomic Swap:</strong> 用new value更新memroy word, 返回old value</li>
<li><strong>Compare-and-Swap(CAS):</strong> update one memory word if its original value matches a given value</li>
</ul>
<p>上述都是abstract instructions</p>
<p>具体指令取决于系统架构(architecture)</p>
<p><img src="/Blog/intro/comp_sys/synchronize.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><code>atomic_swap(&amp;lock, 1)</code> 是在请求锁的使用, 只有请求成功才能访问受保护的数据</p>
<p><img src="/Blog/intro/comp_sys/synchronize_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="互斥锁-Mutual-Execution-Mutex-Locks"><a href="#互斥锁-Mutual-Execution-Mutex-Locks" class="headerlink" title="互斥锁(Mutual Execution (Mutex) Locks)"></a>互斥锁(Mutual Execution (Mutex) Locks)</h3><p>Atomic Swap 和 Compare-and-Swap 都是互斥锁</p>
<p><img src="/Blog/intro/comp_sys/synchronize_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h4 id="自旋锁-Mutex-Spinlock"><a href="#自旋锁-Mutex-Spinlock" class="headerlink" title="自旋锁 Mutex(Spinlock)"></a>自旋锁 Mutex(Spinlock)</h4><p><img src="/Blog/intro/comp_sys/synchronize_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><code>acquire</code> 和 <code>release</code> 都必须是原子性操作</p>
<ul>
<li>当等待所的时候会不断的spinning(自旋)<ul>
<li>可能会浪费CPU cycle</li>
<li>No context switching occurs when thread is spinning<ul>
<li>Useful especially for short critical sections</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>广泛应用在多处理器系统</p>
<ul>
<li>A thread keeps spinning on one processor (waiting for lock)</li>
<li>While another thread performs CS on another processor, which will eventually release the lock for the spinning thread </li>
</ul>
<p><br></p>
<h4 id="Semaphores"><a href="#Semaphores" class="headerlink" title="Semaphores"></a>Semaphores</h4><p><strong>Used to control access to a finite number of instances of some resource</strong></p>
<p>一个 semaphore $S$ 就是一个可以被两种原子操作(<code>wait</code>, <code>signal</code>)访问的integer</p>
<ul>
<li>To gain access to resource: call <code>wait</code></li>
<li>To release access: call <code>signal</code></li>
</ul>
<p>$S$ is initialized to the number of resource instances variable</p>
<ul>
<li>$S==0$ 意味着所有resource都被使用</li>
</ul>
<p><img src="/Blog/intro/comp_sys/synchronize_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/synchronize_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/synchronize_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/synchronize_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>此时 <code>wait/signal</code> 指令必须是原子性的</p>
<p>Cannot allow semaphore values to be modified at the same time by more than one process</p>
<p><code>wait</code> and <code>signal</code> become CS (must be protected)</p>
<ul>
<li>禁止中断(interrupts)(uniprocessor systems only)<ul>
<li>对多核操作系统进行中断太expensive</li>
</ul>
</li>
<li>Busy waiting or spinlocks (multiprocessor systems)</li>
</ul>
<p>Busy waiting not completely eliminated</p>
<p>Just got shifted from application-level CS entry to semaphore’s wait and signal commands, which are very short</p>
<p><img src="/Blog/intro/comp_sys/synchronize_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/synchronize_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/synchronize_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/synchronize_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/synchronize_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Classic-Synchronization-Problems"><a href="#Classic-Synchronization-Problems" class="headerlink" title="Classic Synchronization Problems"></a>Classic Synchronization Problems</h2><h3 id="Bounded-Buffer-Problem"><a href="#Bounded-Buffer-Problem" class="headerlink" title="Bounded-Buffer Problem"></a>Bounded-Buffer Problem</h3><p>Processes(threads) sharing a buffer</p>
<p>Producer向buffer中放入元素</p>
<p>Consumers从buffer中提取元素</p>
<p><img src="/Blog/intro/comp_sys/share_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>然而buffer的大小是固定的, 当buffer满了的时候producer要wait, buffer为空的时候consumer wait</p>
<p>有可能出现的问题:</p>
<ul>
<li>Violation of buffer structure (count ++, count —)</li>
<li>Producing when full</li>
<li>Consuming when empty</li>
</ul>
<p><img src="/Blog/intro/comp_sys/synchronize_prob_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/synchronize_prob_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Readers-Writer-Problem"><a href="#Readers-Writer-Problem" class="headerlink" title="Readers-Writer Problem"></a>Readers-Writer Problem</h3><p>reader: 只执行read操作, 不update数据</p>
<p>writer: 既可以read也可以write</p>
<p>需求:</p>
<ul>
<li>可以有多个 reader, 但没有writer</li>
<li>可以有一个writer, 没有 reader</li>
</ul>
<p>解决方案: 读写索(reader-writer lock)</p>
<p>由操作系统提供:</p>
<ul>
<li><code>pthread_rw_lock*</code></li>
<li>一个 process/thread 可以向读写锁请求 read/write lock</li>
</ul>
<p><br></p>
<p>什么时候使用读写锁?</p>
<ul>
<li>当可以简单分别 reader 和 writer 时</li>
<li>reader 比 writer 多</li>
</ul>
<p>Tradeoff: cost vs concurrency</p>
<ul>
<li>More complex to implement that mutex(write only lock)</li>
<li>More overhead to coordinate readers and writers</li>
<li>Higher concurrency by allowing multiples readers</li>
</ul>
<p><img src="/Blog/intro/comp_sys/synchronize_prob_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/synchronize_prob_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><code>writer_acquire</code> 和 <code>writer_release</code> 都比较好理解</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">reader_acquire</span>(RWLock* lock)&#123;<br>	wait(&amp;lock-&gt;mutex);<br>	lock-&gt;read_count ++;<br>	<br>	<span class="hljs-comment">// 如果是第一个reader来请求</span><br>    <span class="hljs-comment">// 那么可能有write还没结束, 所以要等待write结束</span><br>    <span class="hljs-comment">// 而如果在等待的过程中第二个reader请求来了</span><br>    <span class="hljs-comment">// 那么会被 wait(&amp;lock-&gt;mutex) 挡住</span><br>	<span class="hljs-built_in">if</span>(lock-&gt;read_count == <span class="hljs-number">1</span>)<br>		wait(&amp;lock-&gt;rw_mutex);<br>	<span class="hljs-built_in">signal</span>(&amp;lock-&gt;mutex);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同理, 当<code>reader_release</code> 的时候, 如果是最后一个reader那么就要释放<code>rw_mutex</code>这个锁</p>
<p><br></p>
<h3 id="哲学家就餐问题-Dining-Philosophers-Problem"><a href="#哲学家就餐问题-Dining-Philosophers-Problem" class="headerlink" title="哲学家就餐问题 Dining Philosophers Problem"></a>哲学家就餐问题 Dining Philosophers Problem</h3><p>哲学家会在<strong>吃饭</strong>和<strong>思考</strong>两件事情上进行切换</p>
<ul>
<li>To eat, a philosopher needs two forks (at her left and right)</li>
<li>To think, no forks needed</li>
</ul>
<p>Models multiple processes sharing multiple resources</p>
<p>我们的目标是: Coordinate forks utilization among all philosophers</p>
<p><img src="/Blog/intro/comp_sys/synchronize_prob_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/synchronize_prob_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>然而这种方法可能会出现死锁: 当所有哲学家都拿到左叉子, 等待右叉子时</p>
<p><img src="/Blog/intro/comp_sys/synchronize_prob_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="Condition-variable"><a href="#Condition-variable" class="headerlink" title="Condition variable"></a>Condition variable</h4><p><img src="/Blog/intro/comp_sys/synchronize_prob_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h4 id="Synchronization-and-Priorities"><a href="#Synchronization-and-Priorities" class="headerlink" title="Synchronization and Priorities"></a>Synchronization and Priorities</h4><p><img src="/Blog/intro/comp_sys/synchronize_prob_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%98%E5%85%88%E7%BA%A7%E7%BB%A7%E6%89%BF">优先级继承</a></p>
<p><br></p>
<p><br></p>
<h2 id="DeadLock"><a href="#DeadLock" class="headerlink" title="DeadLock"></a>DeadLock</h2><p><img src="/Blog/intro/comp_sys/synchronize_prob_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>为什么会出现死锁?</p>
<ul>
<li>复杂的依赖 (尤其实在大型应用中) <ul>
<li>必须仔细设计锁定策略，以避免循环依赖</li>
</ul>
</li>
</ul>
<p><img src="/Blog/intro/comp_sys/synchronize_prob_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/synchronize_prob_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p>如何处理死锁?</p>
<p>预防: 不让死锁出现. 让上述4个条件中至少有一个不满足</p>
<p>避免：利用调度程序来避免死锁</p>
<p>让系统可以检测死锁并恢复</p>
<ul>
<li>Detection and recovery</li>
</ul>
<p><br></p>
<h3 id="预防死锁-Circular-Wait"><a href="#预防死锁-Circular-Wait" class="headerlink" title="预防死锁: Circular Wait"></a>预防死锁: Circular Wait</h3><p><img src="/Blog/intro/comp_sys/synchronize_prob_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>保证所以同一种顺序进行require lock</p>
<p><br></p>
<h3 id="预防死锁-Hold-and-Wait"><a href="#预防死锁-Hold-and-Wait" class="headerlink" title="预防死锁: Hold and Wait"></a>预防死锁: Hold and Wait</h3><p><img src="/Blog/intro/comp_sys/synchronize_prob_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="预防死锁-No-Preemption"><a href="#预防死锁-No-Preemption" class="headerlink" title="预防死锁: No Preemption"></a>预防死锁: No Preemption</h3><p><img src="/Blog/intro/comp_sys/synchronize_prob_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>当require 一个lock, 如果失败, 说明有其他线程正在访问, 那么就释放所有请求到的锁. 重新执行</p>
<p><br></p>
<h3 id="预防死锁-Mutual-Exclusion"><a href="#预防死锁-Mutual-Exclusion" class="headerlink" title="预防死锁: Mutual Exclusion"></a>预防死锁: Mutual Exclusion</h3><p><img src="/Blog/intro/comp_sys/synchronize_prob_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>不使用lock而是使用原子操作</p>
<p>通过算法来进行控制 (Lock-Free Algorithms)</p>
<p><br></p>
<p><br></p>
<h3 id="Lock-Free-Algorithm"><a href="#Lock-Free-Algorithm" class="headerlink" title="Lock-Free Algorithm"></a>Lock-Free Algorithm</h3><ul>
<li>不使用锁</li>
<li>可能有high performance (not always)</li>
<li>不可能有死锁</li>
<li>Error-prone 编程更加困难<ul>
<li>Exposes intermediate states to all threads –not protected by critical sections any more</li>
<li>Threads must handle data races explicitly</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="通过调度来避免死锁"><a href="#通过调度来避免死锁" class="headerlink" title="通过调度来避免死锁"></a>通过调度来避免死锁</h3><ol>
<li>Know which locks might be requested by which threads</li>
<li>Schedule threads in a way that guarantees no deadlocks can occur</li>
</ol>
<p>缺点: 需要程序员知道global knowledge about all participating threads and resources</p>
<p><img src="/Blog/intro/comp_sys/dead_lock.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/dead_lock_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>缺点: 可能会增加执行的时间</p>
<p><br></p>
<p><br></p>
<h3 id="Detect-and-Recover"><a href="#Detect-and-Recover" class="headerlink" title="Detect and Recover"></a>Detect and Recover</h3><p>允许死锁发生, 通过某些操作来resolve it</p>
<p> deadlock detector 周期性运转</p>
<p>一种可能的approach是: 维护一个图(graph) 记录 dependencies, 检测图中是否有环</p>
<p>如果有环就说明有潜在的deadlock, 那么就restart system or preempt some threads (aka “victims”)</p>
<p>这种方法在database system中常用</p>
<p><br></p>
<p><br></p>
<h2 id="Main-Memory"><a href="#Main-Memory" class="headerlink" title="Main Memory"></a>Main Memory</h2><p><img src="/Blog/intro/comp_sys/main_memory.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>一种实现方法是使用一个base register, 和一个limit register</p>
<p>Physical address = Base + Virtual Address</p>
<p>通过更改Base的指向, 来切换程序</p>
<p><img src="/Blog/intro/comp_sys/main_memory_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h3 id="Free-Space-Management"><a href="#Free-Space-Management" class="headerlink" title="Free Space Management"></a>Free Space Management</h3><p><img src="/Blog/intro/comp_sys/main_memory_19.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_20.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_21.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_22.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_23.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_24.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_25.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_26.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/main_memory_27.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h3><h4 id="Contiguous-vs-Non-contiguous-Allocation"><a href="#Contiguous-vs-Non-contiguous-Allocation" class="headerlink" title="Contiguous vs. Non-contiguous Allocation"></a>Contiguous vs. Non-contiguous Allocation</h4><p><img src="/Blog/intro/comp_sys/paging_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%86%E9%A0%81%E8%A1%A8">分页表</a></p>
<p>Non-contiguous Allocation</p>
<ul>
<li>Process is allocated memory wherever it is available</li>
<li>Divide physical memory into fixed-sized <strong>page frames</strong><ul>
<li>Size is power of 2 (typically 512 bytes to few GBs)</li>
<li>OS keeps track of all free frames</li>
</ul>
</li>
<li>Divide logical memory into pages of the same size as page frames</li>
<li>For program of size n pages, need to find n  free frames</li>
<li>Use page tables to translate logical to physical addresses</li>
</ul>
<p><img src="/Blog/intro/comp_sys/paging_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/paging_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/paging_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/paging_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/paging_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="Implementation-of-Page-Table"><a href="#Implementation-of-Page-Table" class="headerlink" title="Implementation of Page Table"></a>Implementation of Page Table</h4><ul>
<li>Page table is kept in main memory<ul>
<li><strong>page-table base register</strong> (PTBR) points to page table</li>
<li><strong>page-table length register</strong>(PTLR) indicates size of page table<ul>
<li>Most processes do not use all their address space ranges –waste memory space to create page table entries for each possible page</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>将page table保存在memory的缺点:</p>
<p>所有的 data/instruction access 需要请求两次memory access</p>
<p>one for page table and one for data/instruction (<strong>慢</strong>)</p>
<p>解决办法: Translation Look-aside Buffer(TLB)</p>
<p>TLB 存储在cache中</p>
<ul>
<li>Fast-lookup associative memory, typically 32 to 1024 entries</li>
<li>Caches page table entries (of currently running process)</li>
<li>Part of the MMU (hardware)</li>
</ul>
<p><img src="/Blog/intro/comp_sys/paging_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>TLB存储page number和 frame number. 而page table只存储frame number, page number直接作为索引.</p>
<p><br></p>
<p>TLB存储在cache, 它和cache一样, 当TLB miss出现时, 会从page table中读取frame number, 顺便存储到TLB中, 以供未来使用.</p>
<p>如果TLB满了, 我们就需要移除一个已存在的entry</p>
<ul>
<li>OS may participate (mostly hardware)</li>
<li>Some cannot be removed (“wired down”)<ul>
<li>E.g. pages containing kernel code</li>
</ul>
</li>
</ul>
<p>Each entry stores <strong>Address Space Identifier(ASID)</strong></p>
<ul>
<li>Identifier for process</li>
<li>Address translation checks ASID for protection</li>
<li>Allow TLB to hold page table entries for multiple processes simultaneously<ul>
<li>No TLB flush (erase) during context switch</li>
</ul>
</li>
</ul>
<blockquote>
<p>而且 page table 是 per process, 而TLB是shared by entire system</p>
<p>需要在TLB中指出which entry belongs to which process</p>
<p>因为他们可能有同样的logical page number</p>
</blockquote>
<p><br></p>
<h4 id="Effective-Access-Time"><a href="#Effective-Access-Time" class="headerlink" title="Effective Access Time"></a>Effective Access Time</h4><p>假设访问TLB需要<strong>e</strong> time unit</p>
<p>Memory 访问需要 <strong>tm</strong> time unit</p>
<p>$e &lt;&lt; tm$</p>
<p>Hit ratio $\alpha$</p>
<ul>
<li>percentage of times the requested page frame number is found in TLB</li>
</ul>
<p>Effective Access Time:</p>
<script type="math/tex; mode=display">
(e+tm)\alpha + (e+tm+tm)(1-\alpha)</script><script type="math/tex; mode=display">
=e+(2-\alpha)tm</script><p>当 $\alpha$ 接近1, effective access time 接近 <strong>tm</strong></p>
<p><img src="/Blog/intro/comp_sys/paging_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h3 id="Memory-Protection"><a href="#Memory-Protection" class="headerlink" title="Memory Protection"></a>Memory Protection</h3><p>将 protection bits 和 each frame 相关联</p>
<ul>
<li>指明一个page是 read only, read write, 还是 execute-only</li>
<li>One bit for each to allow combinations (linux 0 到 7 权限, $2^3=8$)</li>
</ul>
<p>Another bit (valid-invalid) may be used</p>
<ul>
<li>Valid indicates whether a page is in the process’s address space, i.e., a legal page to access</li>
<li>Invalid indicates that the page is not in the process’s address space (Illegal memory accesses trapped to OS –segfaults!)</li>
</ul>
<p><img src="/Blog/intro/comp_sys/mem_protect.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Shared-Pages"><a href="#Shared-Pages" class="headerlink" title="Shared Pages"></a>Shared Pages</h3><p>shared code</p>
<ul>
<li>one copy of read-only(reentrant) code shared among processes (e.g., editors, compilers, window systems)</li>
<li>如果是 read-write pages, 可以用于process之间的交互</li>
<li><strong>Shared code must appear in the same location in the logical address space of all processes</strong></li>
</ul>
<p>Private data:</p>
<ul>
<li>Each process keeps “private pages” for data</li>
<li>Private pages can appear anywhere in address space</li>
</ul>
<p><img src="/Blog/intro/comp_sys/mem_protect_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/mem_protect_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/mem_protect_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/mem_protect_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/mem_protect_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/mem_protect_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/mem_protect_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/mem_protect_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><br></p>
<h2 id="Virtual-Memory-1"><a href="#Virtual-Memory-1" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>Instructions must be in physical memory to be executed</p>
<ul>
<li>Limit program size to physical memory size</li>
<li>Limit multiprogramming: cannot support a lot of process</li>
</ul>
<p>但是entire address space is typically not need</p>
<p>我们希望: 允许一些 portions of the address to be non-memory resident (not in physical memory)</p>
<ul>
<li>Demand paging: load program code/data pages into memory on demand. e.g. load shared library as needed</li>
<li>Swapping: Stash memory pages away to the swap space backed by stable storage(e.g. disk or flash SSDs)</li>
</ul>
<p><img src="/Blog/intro/comp_sys/virtual_eme_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="Demand-Paging"><a href="#Demand-Paging" class="headerlink" title="Demand Paging"></a>Demand Paging</h4><p>A page is brought into memory only when needed</p>
<p>好处:</p>
<ul>
<li><p>Less I/O needed</p>
</li>
<li><p>Faster response, because we load only the needed (few) pages</p>
</li>
<li><p>More processes can be admitted to the system</p>
</li>
</ul>
<p>Process generates logical (virtual) addresses which are mapped to physical addresses using a page table </p>
<p>If the requested page is not in memory, kernel brings it from hard disk</p>
<h4 id="Swapping"><a href="#Swapping" class="headerlink" title="Swapping"></a>Swapping</h4><p><img src="/Blog/intro/comp_sys/virtual_eme_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Traditionally means swapping out an entire process (all of its pages)</p>
<p>Modern implementations swap out only portions of processes, not entire processes</p>
<ul>
<li>I.e., “swapping with paging”</li>
</ul>
<p><img src="/Blog/intro/comp_sys/virtual_eme_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/virtual_eme_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/virtual_eme_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>当两个进程共享page时, 如果一个进程改变page, 会copy一个新的page, 在此基础上进行修改, 尽可能保证page被共享</p>
<p><img src="/Blog/intro/comp_sys/virtual_eme_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Minor-vs-Major-Page-Faults"><a href="#Minor-vs-Major-Page-Faults" class="headerlink" title="Minor vs. Major Page Faults"></a>Minor vs. Major Page Faults</h3><p>Major Page fault:</p>
<ul>
<li>Need to bring page from disk </li>
<li>Expensive, includes I/O</li>
</ul>
<p>Minor Page Fault:</p>
<ul>
<li>Does not need to bring page from disk </li>
<li>Typically very fast (just updates the page table)</li>
<li>Examples:<ul>
<li>Shared pages (which already in memory) but not linked with the process address space yet</li>
<li>Dynamic memory allocation (malloc) where kernel may not actually allocate physical memory until it is accessed<ul>
<li>May become a bottleneck in some cases (e.g., in-memory database systems)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/Blog/intro/comp_sys/virtual_eme_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/virtual_eme_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/virtual_eme_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h3 id="Page-Replacement-Algorithms"><a href="#Page-Replacement-Algorithms" class="headerlink" title="Page Replacement Algorithms"></a>Page Replacement Algorithms</h3><p>目标: 最小化 page-fault rate</p>
<p>Algorithm evaluation:</p>
<ul>
<li>Take a particular sequence of memory page references</li>
<li>Compute number of page faults that will occur if we follow the access sequence</li>
</ul>
<p><img src="/Blog/intro/comp_sys/virtual_eme_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/virtual_eme_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><p><img src="/Blog/intro/comp_sys/virtual_eme_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/virtual_eme_19.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>优点: 简单容易实现</p>
<p>缺点: 性能不一定好. (May replace a page that is used heavily, Belady’s anomaly)</p>
<p><img src="/Blog/intro/comp_sys/virtual_eme_20.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p><img src="/Blog/intro/comp_sys/virtual_eme_21.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h4 id="Second-chance-Clock-Replacement"><a href="#Second-chance-Clock-Replacement" class="headerlink" title="Second-chance (Clock) Replacement"></a>Second-chance (Clock) Replacement</h4><p><img src="/Blog/intro/comp_sys/virtual_eme_22.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>当<code>ref_bit</code> 为1时, 就set为0, 再给它一次机会, 尝试在page进程replace</p>
<p><br></p>
<p><img src="/Blog/intro/comp_sys/virtual_eme_23.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Allocating-Kernel-Memory"><a href="#Allocating-Kernel-Memory" class="headerlink" title="Allocating Kernel Memory"></a>Allocating Kernel Memory</h3><p>Treated differently from user memory</p>
<ul>
<li>Some kernel memory needs to be contiguous <ul>
<li>Some hardware devices interact directly with physical memory</li>
</ul>
</li>
<li>Virtual memory may just be too expensive for the kernel (cannot afford a page fault)</li>
</ul>
<p>Often, a free-memory pool is dedicated to kernel from which it allocates the needed memory</p>
<p>Examples (Unix/Linux)</p>
<ul>
<li>Buddy system</li>
<li>Slab allocation </li>
</ul>
<p><br></p>
<h3 id="Buddy-System"><a href="#Buddy-System" class="headerlink" title="Buddy System"></a>Buddy System</h3><p>Allocate memory from fixed-size segment consisting of physically-contiguous pages</p>
<ul>
<li>Memory allocated using power-of-2 size<ul>
<li>When smaller allocation needed than is available, chunk split into two buddies of next-lower power of 2<ul>
<li>Continue until appropriatesized chunk available</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例如我们有4k, 请求3k, 我们不会划分3k而是直接把4k都给出去.</p>
<ul>
<li>Adjacent chunks (“buddies”) are combined togetherto form a large segment</li>
</ul>
<p><img src="/Blog/intro/comp_sys/alloc_ker.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Slab-Allocator"><a href="#Slab-Allocator" class="headerlink" title="Slab Allocator"></a>Slab Allocator</h3><ul>
<li>Slab Allocator<ul>
<li>Creates caches, each consisting of one or more slabs</li>
<li>Slab is one or more physically contiguous pages</li>
</ul>
</li>
<li>A cache for each unique kernel data structure<ul>
<li>Each cache is filled with object instantiations</li>
<li>Objects are initially marked as free</li>
<li>When structures stored, objects marked as used</li>
</ul>
</li>
<li>Benefits<ul>
<li>Fast memory allocation</li>
<li>No fragmentation</li>
</ul>
</li>
</ul>
<p><img src="/Blog/intro/comp_sys/alloc_ker_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h2 id="Memory-Mapped-Files"><a href="#Memory-Mapped-Files" class="headerlink" title="Memory-Mapped Files"></a>Memory-Mapped Files</h2><p><strong>Mapping a file into memory address space</strong></p>
<ul>
<li>A page-sized portion of the file is read from the file system into a physical frame</li>
<li>Subsequent reads/writes to/from file are treated as ordinary memory accesses</li>
<li>One way of implementing shared memory for IPC</li>
<li>Example: <code>mmap()</code> on Linux/Unix system</li>
</ul>
<p>好处是:</p>
<ol>
<li>高效: memory access are less costly than I/O system calls</li>
<li>简单: I/O operations (e.g. <code>read()</code>, <code>write()</code>)on file are treated as memory accesses. </li>
</ol>
<p><img src="/Blog/intro/comp_sys/alloc_ker_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="VM-Issues-Page-Size-and-Pre-Paging"><a href="#VM-Issues-Page-Size-and-Pre-Paging" class="headerlink" title="VM Issues: Page Size and Pre-Paging"></a>VM Issues: Page Size and Pre-Paging</h3><p>Page size selection impacts:</p>
<ul>
<li>Fragmentation</li>
<li>Page table size </li>
<li>I/O overhead</li>
<li>Locality</li>
</ul>
<p>Pre-Paging: bring in some (or all) of the pages a process will need, before they are referenced</p>
<ul>
<li>在process开始时就减少了page faults的数量</li>
<li>May waste memory and I/O because some of the pre-paged pages may not be used</li>
</ul>
<p><img src="/Blog/intro/comp_sys/alloc_ker_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h3 id="VM-Issues-I-O-interlock"><a href="#VM-Issues-I-O-interlock" class="headerlink" title="VM Issues:  I/O interlock"></a>VM Issues:  I/O interlock</h3><p>考虑下面情况:</p>
<ul>
<li>A process allocates buffer for I/O request (in its own address space) </li>
<li>The process issues I/O request and waits (blocks) for it</li>
<li>Meanwhile, CPU is given to another process, which incurs page fault</li>
<li><strong>The page that contains the buffer as a victim</strong></li>
<li>Later, the I/O device sends an interrupt signaling the request is ready</li>
<li><strong>But the frame that contains buffer is now used by different process</strong></li>
</ul>
<p>solution:</p>
<ul>
<li>Lock the (buffer) page in memory (I/O Interlock) </li>
<li>Make I/O in kernel memory (not in user memory): data is first transferred to kernel buffers then copied to user space</li>
</ul>
<p>其他情况</p>
<ul>
<li>Lock kernel pages to avoid page faults in kernel </li>
<li>Lock page which got brought in recently but hasn’t been used yet</li>
</ul>
<p><br></p>
<h2 id="Storage-and-I-O"><a href="#Storage-and-I-O" class="headerlink" title="Storage and I/O"></a>Storage and I/O</h2><p><img src="/Blog/intro/comp_sys/io.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h3 id="I-O-Architecture"><a href="#I-O-Architecture" class="headerlink" title="I/O Architecture"></a>I/O Architecture</h3><p>Buses:</p>
<ul>
<li>Data paths that provided to enable information between CPU(s), RAM, and I.O devices</li>
</ul>
<p>I/O Bus:</p>
<ul>
<li>Data path that connects a CPU to an I/O device</li>
<li>I/O bus is connected to I/O device by three hardware components<ul>
<li>I/O ports</li>
<li>Interfaces</li>
<li>Device controllers</li>
</ul>
</li>
</ul>
<p><img src="/Blog/intro/comp_sys/io_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Nonblocking-and-Asynchronous-I-O"><a href="#Nonblocking-and-Asynchronous-I-O" class="headerlink" title="Nonblocking and Asynchronous I/O"></a>Nonblocking and Asynchronous I/O</h3><p>blocking: process 会挂起直到 I/O 结束</p>
<ul>
<li>使用简单, 理解简单</li>
<li>一些情况下不够高效</li>
<li>一些情况下不必要</li>
</ul>
<p>Nonblocking: I/O call returns as much as avilable</p>
<ul>
<li>例如: data copy (buffered I/O), user interface</li>
<li>Implemented via multi-threading</li>
<li>Returns quickly with count of bytes read or written</li>
<li>E.g., select() to find if data ready then read() or write() to transfer</li>
</ul>
<p>Asynchronous: process runs while I/O executes</p>
<ul>
<li>I/O subsystem signals process when I/O completed</li>
<li>Difficult to use</li>
</ul>
<p><img src="/Blog/intro/comp_sys/io_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h3 id="Disk-Operation"><a href="#Disk-Operation" class="headerlink" title="Disk Operation"></a>Disk Operation</h3><p>Accessing (reading/writing) a block </p>
<ul>
<li>Move the head to desired track (seek time)</li>
<li>Wait  for desired sector to rotate under the head (rotational latency time) </li>
<li>Transfer the block to a local buffer, then to main memory (transfer time) </li>
</ul>
<p>Should minimize <strong>seek time</strong>, which is proportional to the seek distance (distance moved by the head)</p>
<p><br></p>
<h3 id="Disk-Caches"><a href="#Disk-Caches" class="headerlink" title="Disk Caches"></a>Disk Caches</h3><p>Internally, hard disks have caches (DRAM), 一般比较小 (8MB, 16 MB)</p>
<p>Hold data read from or written to the physical disk structure</p>
<p>Allow the device to respond quickly to requests</p>
<p><br></p>
<p>Write policies:</p>
<ul>
<li>Write-back<ul>
<li>return ‘completed’ status as long as data is in cache</li>
<li>Fast but be dangerous</li>
<li>Need to barriers to “force” data to disk media</li>
</ul>
</li>
<li>Write-through<ul>
<li>Make sure data actually reaches disk(also resides in cache)</li>
<li>Safe but may be slow</li>
</ul>
</li>
</ul>
<p><br></p>
<p><br></p>
<h2 id="Files-and-Directories"><a href="#Files-and-Directories" class="headerlink" title="Files and Directories"></a>Files and Directories</h2><h3 id="Secondary-Storage-Systems"><a href="#Secondary-Storage-Systems" class="headerlink" title="Secondary Storage Systems"></a>Secondary Storage Systems</h3><p>各种存储介质:</p>
<ul>
<li>Magnetic disks</li>
<li>Flash based solid state drives (SSDs)</li>
<li>Tapes</li>
</ul>
<p>每种介质都有不同的物理特性</p>
<ul>
<li>Storing bits on disks is different from storing them on flash    </li>
</ul>
<p>然而系统会提供a <strong>uniform</strong> view of storage to users</p>
<p>OS creates file systems on storage media</p>
<ul>
<li>Efficiently store and retrieve data</li>
<li>Enable logical view of data<ul>
<li>Files &amp; directories </li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>Linear array of bytes</p>
<p>Persistently record user-defined information on storage</p>
<p>Internally identified by a low-level name: <strong>inode number</strong></p>
<ul>
<li>Application/user not aware of this; they use file names instead</li>
</ul>
<p>Operations:</p>
<ul>
<li>Open, close, read, write, reposition, delete, truncate, etc.</li>
<li>More operations (e.g., copy) can be composed of these primitives</li>
</ul>
<p><img src="/Blog/intro/comp_sys/io_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Ensuring-Data-Persistence"><a href="#Ensuring-Data-Persistence" class="headerlink" title="Ensuring Data Persistence"></a>Ensuring Data Persistence</h3><p>Recap: storage devices buffer data</p>
<p>File systems buffer data, too</p>
<ul>
<li>For better performance</li>
<li>Data written using write() are buffered in memory</li>
<li>Data read using read() are also buffered in memory</li>
<li>Eventually, data gets written to storage<ul>
<li>E.g., periodically</li>
<li>May lose “written” data</li>
</ul>
</li>
</ul>
<p>Many applications require more than eventually guarantees</p>
<ul>
<li>E.g., database systems, web servers</li>
</ul>
<p>Solution: <code>off_t fsync(int fd)</code></p>
<ul>
<li>Filesystem forces all dirty (i.e., not yet written) data to disk for the file referred to by the file description</li>
<li><code>fsync()</code> returns once all of theses writes are complete</li>
</ul>
<blockquote>
<p>给我的感觉类似于java中flush</p>
</blockquote>
<p><img src="/Blog/intro/comp_sys/io_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Directories"><a href="#Directories" class="headerlink" title="Directories"></a>Directories</h3><ul>
<li>Logical grouping of files/directories</li>
<li>Like a file, also has <strong>inode number</strong><ul>
<li>Unix-like systems: directory 同样是 file</li>
</ul>
</li>
<li><code>List &lt;user-readable name, inode number&gt;</code> pairs<ul>
<li>Each entry may refer to a file or directory</li>
</ul>
</li>
<li>Operations<ul>
<li>Search for a file, create a file, delete a file, rename a file</li>
<li>List a directory –see what’s included in the directory</li>
<li>Traverse the file system</li>
</ul>
</li>
</ul>
<p><img src="/Blog/intro/comp_sys/io_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><p><img src="/Blog/intro/comp_sys/io_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_16.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_17.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>当 一个文件的link为0时, 系统就会删除这个文件, 这也是<code>rm -rf</code>的原理</p>
<p><img src="/Blog/intro/comp_sys/io_18.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_19.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_20.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_21.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_22.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h2 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h2><p><img src="/Blog/intro/comp_sys/io_23.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h3 id="File-System-Implementation"><a href="#File-System-Implementation" class="headerlink" title="File System Implementation"></a>File System Implementation</h3><p>Two aspects for implementing a file system:</p>
<p><strong>Data structures:</strong></p>
<p>On-disk data structures</p>
<ul>
<li>Directory structure, number of blocks, location of free blocks, boot information, …</li>
<li>(In addition to data blocks, of course)</li>
</ul>
<p>In-memory structures</p>
<ul>
<li>For managing file system at runtime</li>
<li>Per-process open-files table, system-wide mount table…</li>
<li>Improve performance (caching)</li>
</ul>
<p><strong>Access methods:</strong></p>
<ul>
<li>Handling calls made by processes to open, close, read, write, etc</li>
</ul>
<p><img src="/Blog/intro/comp_sys/io_24.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_25.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_26.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_27.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_28.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_29.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_30.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><br></p>
<h3 id="Allocating-and-Managing-Data-Blocks"><a href="#Allocating-and-Managing-Data-Blocks" class="headerlink" title="Allocating and Managing Data Blocks"></a>Allocating and Managing Data Blocks</h3><p>inode:metadata that stores information about actual file data </p>
<ul>
<li>May contain direct pointers (i.e., disk addresses) to data blocks belonging to the file</li>
<li>But inodesize is limited, i.e., number of pointers is limited<ul>
<li>File size is limited</li>
</ul>
</li>
</ul>
<p>Solution: multi-level index</p>
<p><img src="/Blog/intro/comp_sys/io_31.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_32.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_33.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_34.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_35.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_36.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_37.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_38.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_39.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h3 id="File-System-Crash-Consistency"><a href="#File-System-Crash-Consistency" class="headerlink" title="File System Crash Consistency"></a>File System Crash Consistency</h3><p><img src="/Blog/intro/comp_sys/io_40.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_41.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/io_42.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h4 id="The-Crash-Consistency-Problem"><a href="#The-Crash-Consistency-Problem" class="headerlink" title="The Crash Consistency Problem"></a>The Crash Consistency Problem</h4><p>Goal: move the file system from one consistent state to another atomically</p>
<p>Challenges:</p>
<ul>
<li>Disk only commits one write at a time<ul>
<li>But we often need to do multiple writes atomically</li>
</ul>
</li>
<li>Crashes and power failure may happen between writes</li>
</ul>
<p><br></p>
<h4 id="Solution-1-File-System-Checker-fsck"><a href="#Solution-1-File-System-Checker-fsck" class="headerlink" title="Solution 1: File System Checker (fsck)"></a>Solution 1: File System Checker (fsck)</h4><p>Tool for finding inconsistencies in file system and fix them</p>
<ul>
<li>Check superblock, free blocks, inode state, inode pointers, etc.</li>
</ul>
<p>然而它不能解决所有问题:</p>
<p>Example: 文件系统看起来是一致的，但是inode指向垃圾数据</p>
<p>就是说我们真实的目标是: 确保file system 的 meta data 是 consistent</p>
<h4 id="Items-Checked-by-fsck"><a href="#Items-Checked-by-fsck" class="headerlink" title="Items Checked by fsck"></a>Items Checked by fsck</h4><p><strong>Superblock</strong> :find corrupted superblock</p>
<ul>
<li>Sanity checks such as making sure file system size &gt; number of blocks allocated</li>
</ul>
<p><strong>Free blocks:</strong></p>
<p>Scan inodes, direct and indirect blocks to learn which blocks are allocated</p>
<ul>
<li>Essentially re-building the block allocation bitmaps</li>
<li>Cross check with the bitmaps stored</li>
</ul>
<p>Inode state:</p>
<ul>
<li>Sanity check for corruption<ul>
<li>E.g., type: regular file, symlink, directory</li>
</ul>
</li>
<li>Inode considered suspect and cleared in case of problems<ul>
<li>Not easy to fix</li>
</ul>
</li>
</ul>
<p>Inode links: ensure link count is correct</p>
<ul>
<li>Scan the entire directory tree to build up new link counts<ul>
<li>Update inode to fix wrong counts</li>
</ul>
</li>
<li>“lost+found” directory<ul>
<li>Inode that has no directories referencing it</li>
</ul>
</li>
</ul>
<p>Duplicates:</p>
<ul>
<li>Check for two different inodes pointing to the same block<ul>
<li>Clear the obviously wrong inode or copy the block</li>
</ul>
</li>
</ul>
<p>Bad blocks:</p>
<ul>
<li>Scan through the list of pointers, check for “bad pointers”<ul>
<li>Example: pointer pointing to block number outside partition size</li>
</ul>
</li>
</ul>
<p>Directories:</p>
<ul>
<li>Additional integrity checks for directory files<ul>
<li>Making sure “.” and “..” are the first two entries</li>
<li>Each inode referred to in the directory is actually allocated</li>
</ul>
</li>
</ul>
<p>Note: fsck doesn’t know about the content of normal files</p>
<p>缺点是太慢</p>
<h4 id="Solution-2-Journaling"><a href="#Solution-2-Journaling" class="headerlink" title="Solution 2: Journaling"></a>Solution 2: Journaling</h4><p><img src="/Blog/intro/comp_sys/journaling.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/journaling_1.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/journaling_2.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<h4 id="Writing-Transaction-to-Journal"><a href="#Writing-Transaction-to-Journal" class="headerlink" title="Writing Transaction to Journal"></a>Writing Transaction to Journal</h4><p>Alternative 1:one request at a time</p>
<ul>
<li>1 for each of: TxB, bitmap, inode, data block, TxE</li>
<li>Five disk write requests</li>
<li>Slow</li>
</ul>
<p><img src="/Blog/intro/comp_sys/journaling_3.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/journaling_4.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/journaling_5.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p>Case 1:Crash happens before transaction is written</p>
<ul>
<li>Skip the pending updates</li>
</ul>
<p>Case 2:Crash happens after transaction is written but before checkpoint</p>
<ul>
<li>Scan the log and look for transactions that have committed</li>
<li>Continue with the checkpoint process for each transaction (aka replay the transaction)</li>
</ul>
<p>Case 3:Crash happens during checkpointing</p>
<ul>
<li>Redo the checkpointing process again (redundant writes are fine)</li>
</ul>
<p><img src="/Blog/intro/comp_sys/journaling_6.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/journaling_7.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/journaling_8.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/journaling_9.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/journaling_10.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/journaling_11.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/journaling_12.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/journaling_13.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/journaling_14.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>
<p><img src="/Blog/intro/comp_sys/journaling_15.PNG" srcset="/Blog/img/loading.gif" lazyload alt=""></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/Blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82/">计算机底层</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/Blog/tags/%E6%B1%87%E7%BC%96/">汇编</a>
                    
                      <a class="hover-with-bg" href="/Blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                      <a class="hover-with-bg" href="/Blog/tags/Linux/">Linux</a>
                    
                      <a class="hover-with-bg" href="/Blog/tags/C/">C</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/Blog/2020/09/12/computer-graphic/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">图像学</span>
                        <span class="visible-mobile">Antaŭa afiŝo</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/Blog/2020/08/27/graph-theory/">
                        <span class="hidden-mobile">图论</span>
                        <span class="visible-mobile">Sekva afiŝo</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Enhavtabelo</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Serĉi</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">ŝlosivorto</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/Blog/js/events.js" ></script>
<script  src="/Blog/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/Blog/js/local-search.js" ></script>



  
    <script  src="/Blog/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/Blog/js/boot.js" ></script>


</body>
</html>
