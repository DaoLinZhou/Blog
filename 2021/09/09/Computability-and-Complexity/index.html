

<!DOCTYPE html>
<html lang="" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Daolin">
  <meta name="keywords" content="">
  
    <meta name="description" content="图灵机https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E5%9B%BE%E7%81%B5%E6%9C%BA  所有可以用图灵机解决的问题都可以用编程语言解决 量子图灵机可以解决的问题也都可以使用图灵机解决, 只不过更耗时   Unsolvable ProblemsThere exist an unsolvable problem. 这里, unsolvable 指的是无法被jav">
<meta property="og:type" content="article">
<meta property="og:title" content="Computability and Complexity">
<meta property="og:url" content="https://daolinzhou.github.io/2021/09/09/Computability-and-Complexity/index.html">
<meta property="og:site_name" content="Daolin&#39;s Repository">
<meta property="og:description" content="图灵机https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E5%9B%BE%E7%81%B5%E6%9C%BA  所有可以用图灵机解决的问题都可以用编程语言解决 量子图灵机可以解决的问题也都可以使用图灵机解决, 只不过更耗时   Unsolvable ProblemsThere exist an unsolvable problem. 这里, unsolvable 指的是无法被jav">
<meta property="og:locale">
<meta property="og:image" content="https://daolinzhou.github.io/intro/cmpt308/turing-machine.PNG">
<meta property="article:published_time" content="2021-09-10T03:40:37.000Z">
<meta property="article:modified_time" content="2021-12-07T20:25:08.553Z">
<meta property="article:author" content="Daolin">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://daolinzhou.github.io/intro/cmpt308/turing-machine.PNG">
  
  
  <title>Computability and Complexity - Daolin&#39;s Repository</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"daolinzhou.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Hejmpaĝo
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Arkivoj
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Kategorioj
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Etikedoj
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                Pri
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/intro/imprinting2.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Computability and Complexity">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-09-09 20:40" pubdate>
        September 9, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      33k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      272 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Computability and Complexity</h1>
            
            <div class="markdown-body">
              <span id="more"></span>

<h1 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h1><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA">https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA</a> </p>
<p>所有可以用图灵机解决的问题都可以用编程语言解决</p>
<p>量子图灵机可以解决的问题也都可以使用图灵机解决, 只不过更耗时</p>
<br>

<h2 id="Unsolvable-Problems"><a href="#Unsolvable-Problems" class="headerlink" title="Unsolvable Problems"></a>Unsolvable Problems</h2><p><strong>There exist an unsolvable problem.</strong></p>
<p>这里, unsolvable 指的是无法被java程序(图灵机)计算出来</p>
<p>problem 指的是一个function $f$, 它可以把一个finite binary string 映射为 1 或 0 (True or False)</p>
<br>

<p>就是说有些问题无法用计算机解决</p>
<br>

<p>这个可以证明出来, 我们只要证明说 problem 的数量大于 program的数量, 那么就说明一些 problem 没有 program 来计算, 因此无法解决</p>
<p>然而 problem 的数量和 program 的数量都是无穷大, 我们需要比较两个无穷大.</p>
<p>这里的思路就是: 我们要证明 problem 的数量等于real number的数量, 而 program 的数量等于 integer number 的数量, real number 的数量大于 integer number 的数量, 因此得以证明.</p>
<blockquote>
<p>对比两个 inf set 的思想就是寻找 one-to-one mapping.</p>
<p>例如比较 set A, set B 的大小, 我们找到 A 和 real number 的 1-1 mapping, 找到 B 和 integer number 的 1-1 mapping, 这样就证明 A 的size 比B大</p>
</blockquote>
<br>

<p><strong>证明: programs 是 countable 的</strong></p>
<p>每个 program text 可以转换为 finite binary string. 而所有<strong>finite binary string</strong> 是 countable 的, 可以枚举它们<br>$$<br>\epsilon, 0, 1, 00, 01, 10, 11, 000,….<br>$$<br>$\epsilon$ 代表 empty string</p>
<p>忽略那些不是program text 的 finite binary string, 就得到了 programs</p>
<br>

<p><strong>证明: Set of all computational problems (function from binary string to 0 or 1) is uncountable</strong></p>
<p>和上面一样 每个function 可以通过 finite binary string 被 identified<br>$$<br>f(\epsilon), f(0), f(1), f(00), f(01), f(10), f(11), f(000),….<br>$$<br>That is the <strong>truth table</strong> of $f$</p>
<p>假设我们可以枚举所有 infinite binary sequence. 并将它们按行排列 $\alpha_1, \alpha_2, \alpha_3…$ , $\alpha_i$ 代表它在第 $i$ 行</p>
<p>我们要寻找一个不存在于这个枚举中的 binary sequence来证明假设错误, 就是说我们无法枚举所有 infinite binary sequence, 即 uncountable</p>
<p>这里使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument">对角论证法</a></p>
<p>可以构建出一个这样的 binary sequence</p>
<p>因此假设错误. Set of all computational problems is uncountable</p>
<br>

<p>由于computational problems 的集合远大于 program 的集合</p>
<p>所以一定存在无法解决的问题</p>
<blockquote>
<p>halting problem 就是一个无法被解决的问题</p>
</blockquote>
<br>

<h2 id="DFA-NFA"><a href="#DFA-NFA" class="headerlink" title="DFA, NFA"></a>DFA, NFA</h2><p><a href="https://daolinzhou.github.io/Blog/2021/05/14/Principles-of-Compiler-Design/#Deterministic-Finite-Automaton-DFA">https://daolinzhou.github.io/Blog/2021/05/14/Principles-of-Compiler-Design/#Deterministic-Finite-Automaton-DFA</a></p>
<p>NFA 转 DFA 的算法本质上是<strong>广度优先遍历</strong></p>
<p>对于初始状态$q_0$, 寻找它的 $\epsilon$ closure, 称为 set $S_1$, 这个 $S_1$ 就是DFA的第一个state $q_0’$​</p>
<blockquote>
<p> $\epsilon$ closure 代表当前状态只通过$\epsilon$ 可以到达的状态的集合</p>
</blockquote>
<p>DFA的第二个状态是由DFA第一个状态向前”走一步”得到的, 因此, 将$S_1$中的所有 state 推进一步 ($\epsilon$ 除外), 再取 $\epsilon$ closure, 得到 $S_2$ 即使DFA的第二个state $q_1’$</p>
<p><img src="/Blog/Blog/intro/cmpt308/nfa2dfa.PNG" srcset="/img/loading.gif" lazyload></p>
<p><img src="/Blog/Blog/intro/cmpt308/nfa2dfa_1.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<h2 id="Regular-Operations"><a href="#Regular-Operations" class="headerlink" title="Regular Operations"></a>Regular Operations</h2><p>regular operation 支持3种运算</p>
<p>union:</p>
<p><img src="/Blog/Blog/intro/cmpt308/re.PNG" srcset="/img/loading.gif" lazyload></p>
<p>concatenation:</p>
<p><img src="/Blog/Blog/intro/cmpt308/re_1.PNG" srcset="/img/loading.gif" lazyload></p>
<p>star:</p>
<p><img src="/Blog/Blog/intro/cmpt308/re_2.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<p>Claim: The class of regular language is closed under regular operation</p>
<p><strong>证明Union</strong></p>
<p>假设有两个 regular language A 和 B, A accepted by $N_A$, $B$ accepted by $N_B$</p>
<p>$A\cup B$​ 就 accepted by following NFA</p>
<p><img src="/Blog/Blog/intro/cmpt308/re_3.PNG" srcset="/img/loading.gif" lazyload></p>
<p>$A \circ B$</p>
<p><img src="/Blog/Blog/intro/cmpt308/re_4.PNG" srcset="/img/loading.gif" lazyload></p>
<p>$A^{*}$</p>
<p><img src="/Blog/Blog/intro/cmpt308/re_5.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<blockquote>
<p>$(1\cup 0)^\star \equiv (1^{\star} 0^{\star})^\star$</p>
</blockquote>
<br>

<p>$L(R)$ 代表 regular language</p>
<p>regular expression 转 regular language </p>
<p><img src="/Blog/Blog/intro/cmpt308/re_6.PNG" srcset="/img/loading.gif" lazyload></p>
<p>Claim: a language $L$ is regular iff $L(R)$ for some regular expression R</p>
<p>证明: </p>
<p>(1) regular expression 转 NFA</p>
<p>对于一个regular expression, 我们可以把它转化成一个tree(可以看作语法树)</p>
<p><img src="/Blog/Blog/intro/cmpt308/re_7.PNG" srcset="/img/loading.gif" lazyload></p>
<p>之后解析树来构成图(NFA)</p>
<p>(2) FA 转 regular expression</p>
<p>首先我们可以把所有FA转换一下, 添加一个头节点, 以及一个尾节点, 来统一输入输出</p>
<p><img src="/Blog/Blog/intro/cmpt308/re_8.PNG" srcset="/img/loading.gif" lazyload></p>
<p>之后我们对它不断地提取, 简化</p>
<p>把每个这样的操作</p>
<p><img src="/Blog/Blog/intro/cmpt308/re_9.PNG" srcset="/img/loading.gif" lazyload></p>
<p><img src="/Blog/Blog/intro/cmpt308/re_10.PNG" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>注意: p 可以等于 q, 但是 p,q 不能等于qrip</p>
<p>如果p, q之间不存在edge, 我们可以看作存才一个edge with empty set, 就相当于这条边无法走过</p>
<p><img src="/Blog/Blog/intro/cmpt308/re_11.PNG" srcset="/img/loading.gif" lazyload></p>
<p>empty set 就是不接收任何 regular expression</p>
</blockquote>
<br>

<h2 id="Non-regular-Language"><a href="#Non-regular-Language" class="headerlink" title="Non-regular Language"></a>Non-regular Language</h2><p>Regular language 只是 language 中的一部分, 还有 non-regular language</p>
<h3 id="Pumping-lemma"><a href="#Pumping-lemma" class="headerlink" title="Pumping lemma"></a>Pumping lemma</h3><p>考虑这种情况</p>
<p><img src="/Blog/Blog/intro/cmpt308/re_12.PNG" srcset="/img/loading.gif" lazyload></p>
<p>我们创建的新NFA接收这种形式的string $xy^iz$​</p>
<p>pumping lemma就是说如果 $w &#x3D; xyz \in L$​</p>
<p> <img src="/Blog/Blog/intro/cmpt308/re_15.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<p>证明<img src="/Blog/Blog/intro/cmpt308/re_13.PNG" srcset="/img/loading.gif" lazyload> 不是正则表达式</p>
<p>反证:</p>
<p>假设它是regular expression</p>
<p>就是说存在 DFA for L on $p$ states, $p \in \N$</p>
<p>考虑 $w \in L$​, w 的长度大于等于 p ($|w| \ge p$​), 这种形式的正则肯定有这样一个string.</p>
<p>那么根据假设 DFA accepts w</p>
<p>根据抽屉原理, 由于$|w| \ge p$​, 肯定有一个state 我们进入了两次</p>
<p><img src="/Blog/Blog/intro/cmpt308/re_14.PNG" srcset="/img/loading.gif" lazyload></p>
<p>也就是说我们可以选择让$w&#x3D;p$​, 即 $0^p1^p$</p>
<p>根据 pumping lemma, 有三种情况</p>
<ol>
<li><p>x只包含0, y包含01, z只包含1</p>
<p>如果此时我们 repeat $y$, 因为 这个language accept $xyz$ 所以accept $xy^iz$ 此时会出现 0101这种交错的string, 这种string不应该被accept, 但是accept</p>
</li>
<li><p>x只包含0, y只包含0, z只包含1</p>
<p>同样如果 repeat y, 0的个数会超过1的个数, 和 regular language 不符合</p>
</li>
<li><p>x只包含0, y只包含1, z只包含1</p>
<p>同上</p>
</li>
</ol>
<p>注意这里 $y\ne \epsilon$ 因为这是一个DFA, 所以没有 $\epsilon$ edge </p>
<br>

<br>

<h3 id="Decidable-properties-of-DFAs"><a href="#Decidable-properties-of-DFAs" class="headerlink" title="Decidable properties of DFAs"></a>Decidable properties of DFAs</h3><ol>
<li>给定字符串$w$, 判断 DFA $M$ 是否accept $w$​, 标记为$A_\text{DFA}$</li>
<li>判断DFA是否不接受任何字符串, 标记为$E_\text{DFA}$</li>
<li>判断两个DFA是否等价, 即 如果w被一个accept, 另一个必须accept, 反之亦然. 标记为$EQ_\text{DFA}$</li>
</ol>
<p><img src="/Blog/Blog/intro/cmpt308/prop.PNG" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>Claim: $A_\text{DFA}, E_\text{DFA}, EQ_\text{DFA}$ are decidable (in polytime)</p>
</blockquote>
<p>$A_\text{DFA}$​ 的解决思路很简单, 只要跑一遍就行, 因为我们知道w, 线性时间内就可以完成</p>
<p>$E_\text{DFA}$​ 可以用图论中的遍历算法, 看能否从起点到达任意一个终点, 如果可以到达就说明不是empty set</p>
<p>$EQ_\text{DFA}$​ 稍微复杂</p>
<p>我们要判断两个DFA $M_1, M_2$ 是否等价</p>
<p>这等价于判断下面式子是否为真<br>$$<br>L(M_1)&#x3D;L(M_2)<br>$$<br>就是说判断两个DFA accept 的 language 是否一样</p>
<p>而这是判断两个集合是否一样, 这又等价于判断</p>
<p><img src="/Blog/Blog/intro/cmpt308/prop_1.PNG" srcset="/img/loading.gif" lazyload><br>$$<br>A\Delta B &#x3D; (A-B) \cup (B-A)<br>$$<br>就是说 $A-B&#x3D;\empty$ 同时 $B-A&#x3D;\empty$</p>
<p>我们可以创建一个新的DFA $C$ 来表示 $A-B$, 之后判断 C 的 language 是否为 empty set (即 $E_\text{DFA}$​, 我们知道怎么判断)</p>
<p>C 要表示 $A-B$, 就是说如果有一个string $x&#x3D;x_1x_2…x_n \in \Sigma^\star$<br>$$<br>M_1 \ \to q_1 \xrightarrow {x_1}q_2\xrightarrow {x_2}\cdots \xrightarrow {x_n}q’<br>$$</p>
<p>$$<br>M_2 \ \to p_1 \xrightarrow {x_1}p_2\xrightarrow {x_2}\cdots \xrightarrow {x_n}p’<br>$$</p>
<p>accept iff $q’ \in F_A$ and $p’\notin F_B$</p>
<p>创建C:</p>
<p>我们让初始state为 $q_0&#x3D; {q_0^A \choose p_0^B}$​</p>
<p>让转换函数为 $\delta {q \choose p} &#x3D; {\delta_A(q)\choose \delta_B(p)}$​ , 即分别对两个状态进行转换​</p>
<p>states 为 $Q&#x3D;Q_A\times Q_B$, 因为我们让每个A的state 和B的state组合, 所以总共的 state 会 等于A,B states number 的乘积</p>
<p>final state 就是 <img src="/Blog/Blog/intro/cmpt308/prop_2.PNG" srcset="/img/loading.gif" lazyload></p>
<p>这样我们就得到了$A-B$​ 的 DFA</p>
<p>同理可以得到 $B-A$ 的 DFA</p>
<p>最后我们判断两个DFA 是否都只接受 empty set</p>
<br>

<br>

<blockquote>
<p>DFA 最简化</p>
<p>DFA 可以在多项式时间内进行最简化</p>
<p>而 NFA 和 regular expression 的最简化是PSPACE-hard 问题, 比 NP-hard 更难</p>
</blockquote>
<br>

<blockquote>
<p>exercise:</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Ty9tpikilAo&amp;t=673s">https://www.youtube.com/watch?v=Ty9tpikilAo&amp;t=673s</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=kZzH8E-s-9o">https://www.youtube.com/watch?v=kZzH8E-s-9o</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=AipSRi3CyLg&amp;t=249s">https://www.youtube.com/watch?v=AipSRi3CyLg&amp;t=249s</a></p>
</blockquote>
<br>

<h2 id="Turing-Machine"><a href="#Turing-Machine" class="headerlink" title="Turing Machine"></a>Turing Machine</h2><p>图灵机说的是由这样一个tape</p>
<p><img src="/Blog/Blog/intro/cmpt308/tm.PNG" srcset="/img/loading.gif" lazyload></p>
<p>每次可以从头部读取一个value, 根据当前状态判断是否要修改当前value, 之后可以向左或向右移动头部</p>
<p>finite automata 只能向右移动, 且无法修改value</p>
<br>

<p>数学语言表达<br>$$<br>M&#x3D;(Q,\Sigma, \Gamma, \delta, q_0, q_{\text{acc}}, q_{\text{rej}})<br>$$<br>$Q$ 是 state 的集合</p>
<p>$\Sigma$  指的是可能的输入字符, 一般用 0, 1 (因为现代计算机都是二进制). 但是可以有其他字符</p>
<p>$\Gamma$​ 指的是 tape 上可能出现的字符, 一般是 $\Sigma$​ 和 $\bigsqcup$​​ (代表empty, 以后用偶尔用$\epsilon$ 表示)</p>
<p>$\delta$​ 是状态转移函数, 根据当前输入判断接下来该怎么作 $\delta : Q \times \Gamma \times (L,R)$​</p>
<br>

<p>我们知道 对于 $L&#x3D;0^n1^n$ 是没有对应的 finite automata 来表示的(用 Pumping Lemma 证明过)</p>
<p>但是这个可以被 Turing Machine 解决</p>
<p>下面是一个<strong>high level algorithm</strong></p>
<ol>
<li>如果 input 是 $\epsilon$​, <strong>Accept</strong></li>
<li>检查 left-most symbol 是否为 $0$, 如果是 $1$ , <strong>Reject</strong>, 如果是 0 则 replace $0$ with $\bigsqcup$​</li>
<li>找到 right-most input symbol</li>
<li>检查 right-most symbol 是否为 $1$, 如果是 $0$, <strong>Reject</strong> , 如果是 1 则 replace $1$ with $\bigsqcup$​</li>
<li>找到 left-most non-blank symbol, 之后回到 Step 1 继续执行</li>
</ol>
<br>

<p><strong>low-level algorithm</strong> </p>
<p>$q_0$ 的作用是: 初始状态下, check left-most value</p>
<p><img src="/Blog/Blog/intro/cmpt308/tm_1.PNG" srcset="/img/loading.gif" lazyload></p>
<p>$\delta(q_0, 0) &#x3D; (q_1, \epsilon, R)$ 指的是: 当前状态为 $q_0$, 如果输入为 0, 就转换状态为 $q_1$, 之后把 0 替换为 $\epsilon$, 把 header 向右移动一位</p>
<br>

<p>$q_1$ 的作用是: 找到 right-most input symbol</p>
<p><img src="/Blog/Blog/intro/cmpt308/tm_2.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<p>$q_2$ 的作用: check right-most input 是否为 1</p>
<p><img src="/Blog/Blog/intro/cmpt308/tm_3.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<p>$q_3$ 的作用:  找到left most symbol, 并重置状态为$q_0$</p>
<p><img src="/Blog/Blog/intro/cmpt308/tm_4.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<br>

<br>

<p>类似的我们还可以用 Turing Machine 来判断 string 是否为 Palindromes</p>
<p><img src="/Blog/Blog/intro/cmpt308/tm_5.PNG" srcset="/img/loading.gif" lazyload></p>
<p>high-level description:</p>
<ol>
<li>如果 input 是$\epsilon$​​, <strong>Accept</strong></li>
<li>Remember the left-most symbol in a state and erase the symbol</li>
<li>找到 right most symbol</li>
<li>Check 是否和 remembered 的 symbol 一样, 如果不一样就reject, 一样 就 erase it</li>
<li>找到 left-most symbol, 重新回到 step 1</li>
</ol>
<blockquote>
<p>这里有个问题, 图灵机怎么 remember left-most symbol?</p>
<p>也比较好理解, 假设当前我们在left-most 的位置, 且状态是 $q_0$</p>
<p>我们知道$\Sigma$, 就是所有可能的输入, 在这个例子中假设只有 0 和 1</p>
<p>就是说我在状态 $q_0$ 时, 如果输入0, 则状态转为 $p_0$, 如果输入 1则状态转为 $p_1$</p>
<p>无论 $p_0$ 还是 $p_1$ 它们接下来都要找到 right most symbol. 如果状态是 $p_0$ 读取到 1 reject, 如果读取到 0, 那么就说明匹配成功. $p_1$ 同理</p>
<p>也就是说对于每一种 input, 我们都要设计一个 state, 用来记录</p>
</blockquote>
<br>

<br>

<p>上面两个算法的时间复杂度都是 $O(n^2)$</p>
<p>因为每次都要从一头走到另一头 $n+(n-1)+(n-2)\cdots+1&#x3D;O(n^2)$</p>
<p>一个图灵机的 runtime 是 number of transitions before halts</p>
<p>如果图灵机不halt, 那么就是 inf</p>
<br>

<p>但是如果有图灵机有2个tape, 就只有$O(n)$的复杂度</p>
<p>例如 对于Palindromes 问题, 只需要先用 $O(n)$ 的时间拷贝string到tape 2, 在用$O(n)$的时间对比两个 tape</p>
<p>1-tape $\delta: Q\times \Gamma \to Q\times \Gamma\times (L, R) $</p>
<p>2-tape $\delta: Q\times \Gamma^2 \to Q\times \Gamma^2\times (L, R)^2 $</p>
<blockquote>
<p>Palindromes 问题在 1-tape 图灵机需要 $\Omega (n^2)$​</p>
</blockquote>
<br>

<br>

<p>Claim: $\forall L \in \text{Text}(t_k)$ on a k-tape TM, $\exist$ a 1-tape TM for $L$ with runtime $O(t_k^2)$</p>
<p>就是说在 k-tape 中 $O(t_k)$ 的算法, 可以转换成 1-tape 中$O(t_k^2)$ 的算法</p>
<p>思想: 因为我们不知道算法, 所以我们要基于原本(未知)的算法进行转换</p>
<p>&#x2F;&#x2F; todo 加个图</p>
<p>原本是k-tape, 此时我们把 k tape 整合在一个tape上 $O(kt)$ 由于k是常数所以忽略</p>
<p>这个新的tape的长度最长为$O(t_k)$, 因为原本算法是$O(t_k)$, 原本k-tape在 $O(t_k)$ 次操作后最多形成k个$O(t_k)$长度的tape, 由于k是常数忽略, 所以整合到一起就是 $O(t_k)$</p>
<br>

<p>之后原本k-tape时, 每一步操作是 $O(1)$, 因为我们有 k 个tape的header, 当整合到1-tape时, 每次操作我们要先找到对应的header再进行操作, 这个时间复杂度是$O(t_k)$ 因为最坏情况我们需要从头找到尾, 而tape的长度是 $O(t_k)$.</p>
<p>就是说k-tape中的一步操作对应 1-tape中$O(t_k)$步操作, k-tape算法是 $O(t_k)$的复杂度, 所以 1-tape中就是$O(t_k^2)$</p>
<br>

<br>

<h3 id="Universal-Turing-Machine"><a href="#Universal-Turing-Machine" class="headerlink" title="Universal Turing Machine"></a>Universal Turing Machine</h3><p>对于不同的任务, 我们要创建一般新的图灵机(物理意义上的创建), 图灵说, 有一个图灵机(universal turing machine, UTM), UTM可以接收输入 <code>&lt;M, w&gt;</code>, M 是 图灵机, w 是它的输入. 就是说 <code>U(&lt;M, w&gt;)</code> 可以模拟 <code>M(w)</code> (accepting iff M accepts w)</p>
<p>这样我们就可以在同一个硬件上运行不同软件</p>
<p>然而这也是有代价的, 原本$O(t_M)$​的复杂度在1-tape machine中会变为$O(t_M^2)$</p>
<p>而在 2-tape 中可以优化为 $O(t_M\log t_M)$​</p>
<p>图灵的UTM是第一个compiler, 也是现代电脑的雏形</p>
<br>

<p>图灵创建它的动机是用来展示有一些算法无法被图灵机计算</p>
<br>

<h3 id="Decidable-language"><a href="#Decidable-language" class="headerlink" title="Decidable language"></a>Decidable language</h3><p>定义: A language $L\subseteq \Sigma^\star$​​ is called decidable, if there exists a TM M s.t.</p>
<ol>
<li>M halts on every input $x\in \Sigma^\star$​ (get a decision) (即对于任何输入都不会一直运行下去)</li>
<li>M accepts every $x \in L$ and M rejects every $x \notin L$</li>
</ol>
<p>一般情况下, 给一个图灵机一个 input, 可能有3种情况</p>
<ol>
<li>accept</li>
<li>reject</li>
<li>run forever</li>
</ol>
<p>第三种是最特殊的</p>
<br>

<h4 id="Semi-decidable-language"><a href="#Semi-decidable-language" class="headerlink" title="Semi-decidable language"></a>Semi-decidable language</h4><p>然而Decidable language 的要求还是有点高, 我们稍微降低一下要求:</p>
<p>定义: A language $L\subseteq \Sigma^\star$​ is called semi-decidable, if there exists a TM M s.t.</p>
<ol>
<li>$\forall x \in \Sigma^\star, x\in L \to \text{M on x accept}$</li>
<li>$\forall x \in \Sigma^\star, x\notin L \to \text{M on x does not accept}$​</li>
</ol>
<p>这里的简化的点就是 “does not accept”, 因为对于一个不被accept 的input, 有可能会loop forever, 我们无法判断是否reject</p>
<br>

<h4 id="Decider"><a href="#Decider" class="headerlink" title="Decider"></a>Decider</h4><p>定义: A TM M is called a decider if M <strong>halts</strong> on <strong>every input</strong></p>
<br>

<h4 id="Halting-Problem-A-TM"><a href="#Halting-Problem-A-TM" class="headerlink" title="Halting Problem $A_{TM}$"></a>Halting Problem $A_{TM}$</h4><p>给定图灵机 M 以及 input w</p>
<p>decide: Does M <strong>accept</strong> w?</p>
<br>

<p>$A_{TM}$ 是semi-decidable</p>
<p>对于给定<code>&lt;M,w&gt;</code>只要在 M上运行 w 就可以的.</p>
<br>

<p>但是$A_{TM}$ is not decidable</p>
<p>证明:</p>
<ol>
<li>我们要定义一个language $D$, 并且证明D is not semi-decidable</li>
<li>证明如果$A_{TM}$ is decidable, 那么 $D$ is decidable, 但是根据(1) 的结论, 我们已经证明D is not decidable, 所以$A_{TM}$ is not</li>
</ol>
<p>对于一个图灵机 M, 我们可以有两种视角来看它</p>
<ol>
<li>它可以是一个可执行程序</li>
<li>它可以是一个字符串(在前面我们就证明过图灵机和 Natural number 的对等)</li>
</ol>
<p>因此我们可以创建一个表格</p>
<table>
<thead>
<tr>
<th></th>
<th><code>&lt;M1&gt;</code></th>
<th><code>&lt;M2&gt;</code></th>
<th><code>&lt;M3&gt;</code></th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>M1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>…</td>
</tr>
<tr>
<td>M2</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>…</td>
</tr>
<tr>
<td>M3</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>…</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p><code>(Mi, &lt;Mi&gt;) = 1</code> 说明 Mi(程序) accept <code>&lt;Mi&gt;</code>(自身的字符串)</p>
<p>思路和对角论证法一样</p>
<p>创建 language <code>D=&#123;&lt;Mi&gt;| Mi does not accept &lt;Mi&gt;&#125;</code></p>
<p>就是说在table中 $D$ 的第一个元素和 $M_1$ 的第一个元素不同…</p>
<br>

<p>阶段1</p>
<p>证明 <strong>D is not semi-decidable</strong></p>
<p>假设D is semi-decidable, 就说明 there exist TM $M_k$ s.t. $M_k$ semi-decides D</p>
<p>那么 如果对 $M_k$ 输入 <code>&lt;Mk&gt;</code> 会怎么样</p>
<ol>
<li><p>accept, 那么 $M_k \notin D$ (definition of D), 但由于 M Semi-decide D ($$L(M)&#x3D;D$$) 因此 M不应该 accept <code>&lt;Mk&gt;</code> 因为 $M_k \notin D$ , 矛盾</p>
</li>
<li><p>does not accept, 那么 $M_k \in D$​ (definition of D), 但由于 M Semi-decide D ($L(M)&#x3D;D$)因此 M应该 accept <code>&lt;Mk&gt;</code>, 矛盾</p>
</li>
</ol>
<p><img src="/Blog/Blog/intro/cmpt308/d.PNG" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>这个问题替换 $D$ 和 $L(M)$ 是最关键的一步, 因此在定义$D$ 时, 要和 $L(M)$ 扯上关系</p>
</blockquote>
<p>所以 D is not semi-decidable</p>
<br>

<p>阶段2</p>
<p>证明: <strong>如果 Halting problem is decidable, 那么 D is decidable</strong></p>
<p>我们的假设是 <code>A_TM = &#123;&lt;M, w&gt;| TM M accepts w&#125;</code> is decidable</p>
<p>假设 Decider TM 是 $H$</p>
<p>我们想证明:</p>
<p><code>D=&#123;&lt;M&gt;|TM M doesn&#39;t accept &lt;M&gt;&#125;</code> is decidable</p>
<p>要证明这是decidable, 我们可以创建一个decider, 这个decider做的工作就是对 $H(M, \langle M\rangle)$ 进行取反</p>
<p><img src="/Blog/Blog/intro/cmpt308/halt.PNG" srcset="/img/loading.gif" lazyload></p>
<p>通过这个 decider 我们可以 decide D, </p>
<p>因此 如果 $A_{TM}$ 存在, 那么 D 存在 decider, 但是我们知道D无法被decide, 因此矛盾</p>
<p>说明 $A_{TM}$ 不存在</p>
<br>

<br>

<h4 id="相关证明"><a href="#相关证明" class="headerlink" title="相关证明"></a>相关证明</h4><p>我们知道 <code>A_TM = &#123;&lt;M, w&gt; | TM M accepts w&#125;</code> 是 undecidable problem, 但是 semi-decidable</p>
<p>而 我们创建的 language <code>D=&#123;&lt;M&gt;|TM M doesn&#39;t accept &lt;M&gt;&#125;</code> 甚至不是 semi-decidable</p>
<p><img src="/Blog/Blog/intro/cmpt308/halt_1.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<p>那么 language​</p>
<p><img src="/Blog/Blog/intro/cmpt308/halt_2.PNG" srcset="/img/loading.gif" lazyload></p>
<p>是否是decidable?</p>
<br>

<p>明显是 undecidable 的</p>
<p>因为我们只要对 $A_{TM}$​ 的 output 取反就得到 $\overline A_{TM}$​</p>
<p>如果如果 $A_{TM}$ 是 decidable, 那么 $\overline A_{TM}$ 也是decidable, 反过来也一样<br>$$<br>\overline A_{TM} \text{ is decidable} \iff A_{TM}\text{ is decidable}<br>$$</p>
<blockquote>
<p>结论: The class of decidable language is closed under complement.<br>$$<br>\overline L \text{ is decidable} \iff L \text{ is decidable}<br>$$<br><img src="/Blog/Blog/intro/cmpt308/halt_3.PNG" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<br>

<p>证明 $\overline A_{TM}$ is not semi-decidable</p>
<p>方法1</p>
<p>证明这个等价于证明 <code>D=&#123;&lt;M&gt;|TM M doesn&#39;t accept &lt;M&gt;&#125;</code> is demi-decidable, 而我们知道 D is not demi-decidable(对角论证法)</p>
<p>所以 $\overline A_{TM}$ is not semi-decidable</p>
<br>

<p>方法 2</p>
<p>我们已知  $A_{TM}$​ 是 semi-decidable(已知), 如果  $\overline A_{TM}$​ 也是 semi-decidable (假设), 那么$A_{TM}$​ 就是 decidable (将二者结合形成一个算法). 但是我们知道 $A_{TM}$ 不是 decidable, 所以假设错误</p>
<p>怎么进行结合?</p>
<blockquote>
<p>结论:</p>
<p>let $L\subseteq \Sigma^\star$​ be any semi-decidable language such that $\overline L$ is also semi-decidable. Then $L$ is decidable</p>
</blockquote>
<p>证明</p>
<p><img src="/Blog/Blog/intro/cmpt308/halt_4.PNG" srcset="/img/loading.gif" lazyload></p>
<p>只要对给定input, 在两个TM中同时运行, 总有一个会accept, 因为两个都是 semi-decidable</p>
<p>如果 $x\in L$ semi-decider for $L$ accepts</p>
<p>反之如果 $x \notin L$, semi-decider for $\overline L$ accepts</p>
<br>

<p>如何同时运行两个或以上的图灵机</p>
<p>简单来说就是用线程的思想, 创建一个新的图灵机, 这个图灵机会先运行 x 步 TM1, 在运行 x 步TM2, 在运行 y 步TM1…(“dovetailing”)</p>
<br>

<blockquote>
<p>结论: The class of semi-decidable language is <strong>not</strong> closed under complement</p>
</blockquote>
<p><img src="/Blog/Blog/intro/cmpt308/halt_5.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<br>

<p>一些其他的 undecidable language</p>
<ol>
<li><code>E_TM = &#123;&lt;M&gt; | M is TM s.t. L(M) = &#123;&#125;&#125;</code> (M doesn’t accept any string)</li>
<li><code>ALL_TM = &#123;&lt;M&gt; | M is a TM s.t. L(M) = Σ*&#125;</code> (M accept every string)</li>
<li><code>EQ_TM = &#123;&lt;M1, M2&gt; | M1 &amp; M2 are TMs s.t. L(M1)=L(M2)&#125;</code></li>
</ol>
<p><img src="/Blog/Blog/intro/cmpt308/halt_6.PNG" srcset="/img/loading.gif" lazyload></p>
<p><img src="/Blog/Blog/intro/cmpt308/halt_7.PNG" srcset="/img/loading.gif" lazyload></p>
<p>这里有个要注意的点, R accept $M’$​ 代表 M does not accept w, 因为 R 是 $E_{TM}$​ 的 decider, R accept M’ 说明 L(M’) 是 empty set</p>
<p><img src="/Blog/Blog/intro/cmpt308/halt_8.PNG" srcset="/img/loading.gif" lazyload></p>
<p><img src="/Blog/Blog/intro/cmpt308/halt_9.PNG" srcset="/img/loading.gif" lazyload></p>
<p>这个的思路也简单, 我们可以fix M2, 之后这个问题就可以转化为前两个问题了</p>
<br>

<br>

<h2 id="Rice’s-Theorem"><a href="#Rice’s-Theorem" class="headerlink" title="Rice’s Theorem"></a>Rice’s Theorem</h2><p>定义:</p>
<p><img src="/Blog/Blog/intro/cmpt308/rice_the_7.PNG" srcset="/img/loading.gif" lazyload></p>
<p>叫做 <strong>non-trivial property</strong> if</p>
<ol>
<li><p>$\exists \text { TM } M_1$, $\langle M \rangle \in p $    and    $\exists \text { TM } M_2, \langle M_2\rangle\notin p $</p>
</li>
<li><p>$\forall \text{ TMs M, M’ s.t. } L(M)&#x3D;L(M’)$</p>
<ul>
<li>$\langle  M \rangle \in p \iff \langle M’\rangle \in p$</li>
</ul>
</li>
</ol>
<p>这里讨论一下这两个约束是在干什么</p>
<p>约束(1) 说的是我们不希望 non-trivial property 包含所有的 TM, 有一部分TM有这个 property, 而有一部分TM没有这个 property, 因为所有TM都有的property显然是decidable的</p>
<p>约束(2) 说的是这个 property 描述的是一种语义(功能性), 与具体的代码(实现)没有关系. 只要两个TM有同样的功能, 即$L(M)&#x3D;L(M’)$, 那么这两个 TM 就被认为是等价的(同时存在在某个 property 中)</p>
<br>

<blockquote>
<p>Rice’s Theorem: every non-trivial property $p$ is undecidable</p>
</blockquote>
<p>证明:</p>
<p>Let $M_{\emptyset}$ be a TM s.t. $L(M_\emptyset) &#x3D; \emptyset$, Assume (without loss of generality) $\langle M_\O\rangle\in p$</p>
<blockquote>
<p>为什么 $\langle M_\emptyset\rangle \in p$ 不会 loss of generality</p>
<p>因为如果  $\langle M_\emptyset\rangle \notin p$, 那么  $\langle M_\emptyset\rangle \in \overline p$ 我们可以互换 $p$ 与 $\overline p$ , 使得 $\langle M_\emptyset\rangle \in p$</p>
</blockquote>
<p>Let $M_1$ be any TM s.t. $\langle M_1\rangle \notin p$</p>
<p>证明思路: 假设 $p$ is decidable, 那么我们可以得到一个 decider for $A_{TM}&#x3D;{\langle M,w\rangle |\text{ M accept w}}$, Contradiction!</p>
<p>证明过程:</p>
<blockquote>
<p>对于给定的 $\langle M,w \rangle$ 定义 TM $M’&#x3D;$</p>
<p>“On input $x$,</p>
<p>simulate M on w.</p>
<p>If $M$ accept $w$, </p>
<p>then simulate $M_1$ on $w$ </p>
<p>(accept iff $M_1$ accept)”</p>
</blockquote>
<p>就是说</p>
<p><img src="/Blog/Blog/intro/cmpt308/rice_the.PNG" srcset="/img/loading.gif" lazyload></p>
<p>也就是说 $\langle M’\rangle \in p \iff \langle M,w\rangle \notin A_{TM}$ </p>
<p>$\langle M’\rangle \in p$ 意味着 $L(M’) &#x3D; L(M_\O)$, 也就是说 $M$ doesn’t accept w, 因此 $\langle M, w\rangle \notin A_{TM}$</p>
<p>然而根据假设 $p$ is decidable, 因此我们可以 decide $\langle M’\rangle \in p$, 因此我们也可以decide  $\langle M,w\rangle \in A_{TM}$</p>
<p>我们知道 $A_{TM}$ 无法被decide, 所以矛盾, 假设错误, $p$ <strong>is not decidable</strong></p>
<br>

<p>这意味着: 我们只能运行这个图灵机才知道它在干什么</p>
<br>

<p>Halting problem $A_{TM}$ is undecidable 意味着什么?</p>
<p>No single algorithm is able to decide for every given program $M$ whether $M$ terminates or not</p>
<p>我们不能随机生成一个 program 然后期望有一个算法来验证它的正确性</p>
<br>

<p>但是我们可以 verified 一些 simple programs 的正确性 (simple 意味着 understandable) </p>
<p>Software Engineering 就是为了让我们写出易于理解, 易于验证的代码</p>
<p><img src="/Blog/Blog/intro/cmpt308/rice_the_1.PNG" srcset="/img/loading.gif" lazyload></p>
<p>同理在机器学习中, Explainable AI (XAI) 也是一个热门话题, 如果你无法解释你设计的算法, 那大概率它不会有好的结果</p>
<br>

<br>

<br>

<p>之前我们证明过 $E_{TM} &#x3D; {\langle M \rangle | L(M)&#x3D;\emptyset}$ 是 undecidable,</p>
<p>此时我们就可以用Rice’s Theorem 来直接证明它是 undecidable了</p>
<p>那么 $E_{TM}$ 是否 semi-decidable?</p>
<br>

<h2 id="证明思路"><a href="#证明思路" class="headerlink" title="证明思路"></a>证明思路</h2><p>$E_{TM}$ is not semi-decidable</p>
<p>证明思路: show $\overline A_{TM} \le E_{TM}$ (证明 $\overline A_{TM}$ 比 $E_{TM}$ 简单)</p>
<br>

<p>定义: 对于language $A, B$, 我们说 A is reducible to $B$ (via a mapping reduction) denoted by<br>$$<br>A\le B<br>$$<br>if there is a <strong>computable</strong> function<br>$$<br>R: \Sigma^\star \to \Sigma^\star<br>$$<br>such that $\forall x \in \Sigma^\star$<br>$$<br>x\in A \iff R(x) \in B<br>$$<br><img src="/Blog/Blog/intro/cmpt308/rice_the_2.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<p>这么做的结果, 假设 $A\le B$</p>
<ol>
<li>如果 B 是 decidable, 那么比它简单的 $A$ 也是 decidable</li>
<li>如果 B 是 semi-decidable, $A$ 也是 semi-decidable</li>
</ol>
<p>因为我们可以这样创建一个semi-decider for $A$</p>
<p><img src="/Blog/Blog/intro/cmpt308/rice_the_3.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<p>反过来</p>
<ol>
<li>如果 A 是 undecidable, 比它困难的 B 也是 undecidable</li>
<li>如果 A 是 non-semi-decidable, B 也是 non-semi-decidable</li>
</ol>
<br>

<p>回到问题, 要证明 $E_{TM}$ is not semi-decidable</p>
<p>等价于证明 $\overline A_{TM} \le E_{TM}$</p>
<p>$\overline A_{TM}$ 是 non-semi-decidable</p>
<p>构建$R$ :</p>
<blockquote>
<p>对于 input $\langle M, w\rangle$</p>
<p>定义 M’ &#x3D; </p>
<p>“On input $z$,</p>
<p>Simulate M on w.</p>
<p>If M accepts w,</p>
<p>then accept z”</p>
<p>Output $\langle M’\rangle$</p>
</blockquote>
<p><img src="/Blog/Blog/intro/cmpt308/rice_the_4.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<p>Check $R$ shows $\overline A_{TM} \le E_{TM}$</p>
<ol>
<li>$\langle M, w \rangle \in \overline A_{TM} \to\ \langle M, w\rangle \notin A_{TM}$<ul>
<li>$M$ doesn’t accept $w$</li>
<li>$L(M’)&#x3D;\emptyset$</li>
<li>$\langle M’\rangle \in E_{TM}$</li>
</ul>
</li>
<li>$\langle M, w\rangle \notin \overline A_{TM} \to\  \langle M, w\rangle \in A_{TM}$<ul>
<li>$M$ accept $w$</li>
<li>$L(M’)&#x3D;\Sigma^\star$</li>
<li>$\langle M’\rangle \notin E_{TM}$</li>
</ul>
</li>
</ol>
<p>我们找到了$\overline A_{TM}$ 到 $E_{TM}$ 的映射, 因此 $\overline A_{TM} \le E_{TM}$</p>
<p>因为 $\overline A_{TM}$ 不是 semi-decidable, 所以 $E_{TM}$ 不是 semi-decidable</p>
<br>

<br>

<p>另一个例子:</p>
<p>证明  $E_{TM} \le EQ_{TM}$</p>
<p>我们可以找到$R$:</p>
<p><img src="/Blog/Blog/intro/cmpt308/map.PNG" srcset="/img/loading.gif" lazyload></p>
<p>where $M_\emptyset$ is some fixed TM s.t. $L(M_\emptyset)&#x3D;\emptyset$</p>
<p>由于$E_{TM}$ is not semi-decidable, so does $EQ_{TM}$</p>
<br>

<br>

<p><strong>另一个例子:</strong></p>
<p><img src="/Blog/Blog/intro/cmpt308/inf.PNG" srcset="/img/loading.gif" lazyload></p>
<p>我们要证明:</p>
<ol>
<li>INF is not decidable</li>
<li>INF is not semi-decidable</li>
<li>$\overline{ \text{INF}}$ is not semi-decidable</li>
</ol>
<br>

<p>(1) 可以通过 Rice’s Theorem 直接证明</p>
<p>重点是 2 和 3</p>
<p>先证明 (3)</p>
<p>我们的证明思路是证明 $\overline A_{TM} \le \overline{ \text{INF}}$</p>
<p>这等价于证明 $A_{TM}\le \text{INF}$</p>
<blockquote>
<p>因为我们只要能证明 $A_{TM}\le \text{INF}$ , 那么只要对两边取反即可</p>
</blockquote>
<p>我们希望有一个 computable $R: \langle M, w\rangle \ \to \ \langle M’\rangle$, s.t. $\langle M, w\rangle \in A_{TM} \iff \langle M’\rangle \in \text{INF}$</p>
<p>换句话说 $\text{M accept w} \iff \text{L(M’) is infinite}$</p>
<p>通过给定的 &lt;M, w&gt;, 我们可以构建TM</p>
<p>M’ &#x3D; On input x, simulate M on w, if M accepts w, then accepts x.</p>
<p>有两种情况</p>
<ul>
<li>M accepts w    $\to$    $L(M’)&#x3D;\Sigma^{\star}$ is infinite </li>
<li>M not accept w    $\to$    $L(M’)&#x3D;\emptyset$ is finite</li>
</ul>
<p>so $A_{TM}\le \text{INF}$ </p>
<br>

<p>再证明(2)</p>
<p>证明思路是证明 $\overline A_{TM}\le \text{INF}$ (因为 $\overline A_{TM}$ 不是 semi-decidable)</p>
<p>同样, 我们希望有一个 computable $R: \langle M, w\rangle \ \to \ \langle M’\rangle $, s.t. $\langle M, w\rangle \in \overline A_{TM} \iff \langle M’\rangle \in \text{INF}$</p>
<p>换句话说 $\text{M doesn’t accept w} \iff \text{L(M’) is infinite}$</p>
<p>$\text{M accept w} \iff \text{L(M’) is finite}$</p>
<br>

<p>同样的思路, 通过给定的 &lt;M, w&gt; 构建 TM</p>
<p>M’ &#x3D; On input x, simulate M on w, <strong>if M accept w, then reject x</strong></p>
<p>有两种情况</p>
<p><img src="/Blog/Blog/intro/cmpt308/rice_the_5.PNG" srcset="/img/loading.gif" lazyload></p>
<p>为什么? </p>
<p>如果 M accept w, 那么 reject x, L(M’) 为空是显而易见的</p>
<p>如果 M not accept w, 我们没有让它进行任何操作(没有让它accept), 所以 L(M’) 依然是空</p>
<br>

<p>自然我们就想再添加一个else statement</p>
<p>M’ &#x3D; On input x, simulate M on w, <strong>if M accept w, then reject x else accept x</strong></p>
<p>这里 如果 M not accept w, 有可能是 reject, 这样没有问题, accept x, 但是 M 有可能会一直运行下去(not halting), 此时就有问题了, 因为此时不会 accept x, 也就是说这种情况下 L(M’) 依然为空</p>
<br>

<p>下面就是一个有灵魂的操作了</p>
<p>我们限制 M 的执行次数</p>
<p>M’ &#x3D; On input x, simulate M on w <strong>for</strong> $|x|$ <strong>steps</strong>, <strong>if M accept w, then reject x else accept x</strong></p>
<p>x 是 M’的 input, 这是一个变量, 此时</p>
<p><img src="/Blog/Blog/intro/cmpt308/rice_the_6.PNG" srcset="/img/loading.gif" lazyload></p>
<p>为什么? 分析一下</p>
<p><strong>case 1: M not accept w</strong></p>
<p>此时在 $|x|$ 步 的运行中, 无论得出结果还是没有得出结果, M 都不会 accept w, 就是说 M’ accept x</p>
<p>此时 $L(M’)&#x3D;\Sigma^\star$</p>
<p><strong>case 2: M accept w at</strong> $t$ <strong>step</strong></p>
<p>M 需要 $t$ 步才会得出结论</p>
<p>如果 $|x| &lt; t$, M not accept w, 即 M’ accept x.</p>
<p>然而这种情况是有限的, 我们最多只能找到 $2^{t+1}$ 个这样的字符串 (即长度小于 t 的字符串)</p>
<p>如果 $|x| \ge t$, M accept w, 即 M’ reject x</p>
<p>此时 $L(M’)$ 只是这 $2^{t+1}$ 字符串的集合</p>
<p><img src="/Blog/Blog/intro/cmpt308/rice_the_6.PNG" srcset="/img/loading.gif" lazyload></p>
<p>因此 $\overline A_{TM}\le \text{INF}$</p>
<br>

<br>

<h2 id="Recursively-Enumerable-RE"><a href="#Recursively-Enumerable-RE" class="headerlink" title="Recursively Enumerable(RE)"></a>Recursively Enumerable(RE)</h2><p><img src="/Blog/Blog/intro/cmpt308/re_en.PNG" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>$E$ starts with $\epsilon$ on the input tape</li>
<li>$E$ may run forever</li>
<li>$E$ prints on its write-only output tape strings $s_1, s_2, s_3\cdots$</li>
</ul>
<p>$$<br>L(E) &#x3D; {w\text{ | E prints w at some point}}<br>$$</p>
<p>定义: A language $L$ is called <strong>RE</strong> if there exist enumerator TM $E$ s.t.<br>$$<br>L(E) &#x3D; L<br>$$<br><br></p>
<p>Claim: RE 等价于 Semi-Decidable</p>
<p>(这意味着, 如果 $L\in RE$ 那么 $L$ is semi-decidable, 同时 如果 $L\in \text{Semi-Decidable}$, 那么 $L\in RE$)</p>
<blockquote>
<p>换句话说, 如果 $L$ is semi-decidable, 那么就存在一个enumerator for $L$, 如果执行enumerator会打印出所有 $L$ 中的元素</p>
</blockquote>
<p><strong>证明:</strong></p>
<p>forward &#x3D;&gt; (如果 $L\in RE$ 那么 $L$ is semi-decidable)</p>
<p>Let $L$ be an arbitrary $RE$ language</p>
<p>Let $E$ be an enumerator TM for $L$</p>
<p>我们想要一个 semi-decider TM $M$ for $L$</p>
<p>对于input w, 判断是否在L中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs pseudocode">input w<br><br>Run E &amp; observe string E prints<br>for each s printed by E<br>	if s == w then halt &amp; accept<br>	endif<br>endfor<br></code></pre></td></tr></table></figure>

<p>因此 $L(M) &#x3D; L(E)$</p>
<br>

<p>backward &lt;&#x3D; (如果 $L\in \text{Semi-Decidable}$, 那么 $L\in RE$)</p>
<p>let $w_1, w_2, w_3 \cdots$ be the lex ordering of all strings in $\Sigma^\star$</p>
<p>就是说先根据 string 的长度排序, 再根据字母排序, 即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">for i = 1 ... inf<br>	Run M on w1, w2, w3... wi for i steps on each<br>	if M accepts some wj<br>		print wj<br>endfor<br></code></pre></td></tr></table></figure>

<p>因此 $L(M) &#x3D; L(E)$</p>
<br>

<br>

<h2 id="Nondeterministic-Turing-Machine"><a href="#Nondeterministic-Turing-Machine" class="headerlink" title="Nondeterministic Turing Machine"></a>Nondeterministic Turing Machine</h2><p>Deterministic Turing Machine (DTM)(1-tape)</p>
<p>是这样:<br>$$<br>\delta: Q\times \Gamma \to Q\times \Gamma\times {L, R}<br>$$<br>对于某一个输入, 只有一种输入可能</p>
<p>而NTM是这样<br>$$<br>\delta: Q\times \Gamma \to P(Q\times \Gamma\times {L, R})<br>$$<br>$P$ 指的是power set</p>
<p>例如: $\delta (q, a) &#x3D; {(q_1, a, L), (q_2, b, R), (q_1, b, L)}$</p>
<p>我们可以把 Computation 看作时 Sequence of Configurations</p>
<p><img src="/Blog/Blog/intro/cmpt308/config.PNG" srcset="/img/loading.gif" lazyload></p>
<p>例如在某一时刻运行到 $q_0$ , 可以把它可把$q_0$ 和此时的TM以及读取的位置作为snapshot, encoding成一个字符串</p>
<p>假设下一步是 $\delta(q_0, x_1)&#x3D;(q_1, y_1, R)$</p>
<p><img src="/Blog/Blog/intro/cmpt308/config_1.PNG" srcset="/img/loading.gif" lazyload></p>
<p>此时 DTM 和 NTM 差别就非常明显, DTM是一个path, NTM是一个tree (就像 DFA 和 NFA 一样)</p>
<p><img src="/Blog/Blog/intro/cmpt308/config_2.PNG" srcset="/img/loading.gif" lazyload></p>
<p>这个tree可能无限长, 因为 NTM 也可能有死循环</p>
<br>

<p>同理, NTM M accepts w, if there exists some computation branch that is accepting:</p>
<p><img src="/Blog/Blog/intro/cmpt308/config_3.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<p>对于 language 的定义是和 DTM 一样的.<br>$$<br>L(M) &#x3D; {w \in \Sigma^\star \text{ | M accepts w}}<br>$$</p>
<h3 id="NTM-转-DTM"><a href="#NTM-转-DTM" class="headerlink" title="NTM 转 DTM"></a>NTM 转 DTM</h3><p>对于一个NTM N, DTM M, s.t. $L(M) &#x3D; L(N)$</p>
<p>暴力解法:</p>
<p>M: 对于NTM这个tree, 我们进行广度优先遍历(BFS) 如果某一时刻accept, 那么就accept</p>
<p>但是 M 的运行时间会远远超出 N, 假设N要运行t步, 即DTM要运行大约 $2^t$, (“P vs NP”)</p>
<br>

<p>假设一个NTM $N$ 是一个decider, 如果 $\forall w \in \Sigma^\star$, 所有 computation branch of $N$ on $w$ is finite (i.e. the computation tree is finite)</p>
<p>那么 就会有一个 decider DTM $M$, s.t. $L(N) &#x3D; L(M)$</p>
<p>因为此时tree是finite的, 广度优先遍历肯定会halt</p>
<blockquote>
<p>The classes decidable and semi-decidable stay the same if we allow NTMs</p>
</blockquote>
<br>

<h3 id="为什么使用-NTM"><a href="#为什么使用-NTM" class="headerlink" title="为什么使用 NTM"></a>为什么使用 NTM</h3><p>NTM 可以 non-deterministically guess</p>
<p>例如我们定义<br>$$<br>\delta(q_0, \sqcup) &#x3D; {(q_0,0,R), (q_0, 1, R), (q_1, \sqcup, L)}<br>$$<br>那么这个代表什么?</p>
<p><img src="/Blog/Blog/intro/cmpt308/ntm.PNG" srcset="/img/loading.gif" lazyload></p>
<p>$\forall x&#x3D;x_1x_2\cdots x_n \in {0, 1}^{\star}$</p>
<p>$q_0\epsilon\to ^\star x_1x_2\cdots x_{n-1} q_1x_n$</p>
<br>

<p>$\to^\star$ 意味着进行多次guess</p>
<p>就是说我们可以 “guess” any binary string x</p>
<br>

<p>Different branches of this NTM’s computation (on $\epsilon$) will have different (all possible) string x “guessed” on the tape</p>
<br>

<h3 id="使用NTM证明"><a href="#使用NTM证明" class="headerlink" title="使用NTM证明"></a>使用NTM证明</h3><p>$E_{TM}&#x3D;$<code>&#123;&lt;M&gt; | L(M) = empty set&#125;</code></p>
<p>$\overline E_{TM}&#x3D;$ <code>&#123;&lt;M&gt; | L(M) ≠ empty set&#125;</code></p>
<p>如何证明 $\overline E_{TM}$ is semi-decidable</p>
<br>

<p>证明: 构建可以 semi-decide $\overline E_{TM}$ 的 NTM </p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm">Given &lt;M&gt;<br><br>non-deterministically guess <span class="hljs-keyword">x</span> in Σ*<br>Simulate M on <span class="hljs-keyword">x</span><br>if M accepts <span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> then accept<br></code></pre></td></tr></table></figure>

<p>correctness:</p>
<ul>
<li>如果 <code>&lt;M&gt;</code>$\in \overline E_{TM}$ <ul>
<li>$\exists x \in \Sigma^\star$, M accepts $x$, this $x$ will be guessed on some computation branch. Some branch is accepting, NTM $N$ accepts $\langle M \rangle$</li>
</ul>
</li>
<li>如果 <code>&lt;M&gt;</code>$\notin \overline E_{TM}$<ul>
<li>$L(M) &#x3D; \emptyset$, M doesn’t accept any $x$, all computation branches are non-accepting. NTM $N$ doesn’t accept <code>&lt;M&gt;</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>NTM 允许你同时对所有的 branch 进行 check</p>
</blockquote>
<br>

<h2 id="Self-print"><a href="#Self-print" class="headerlink" title="Self print"></a>Self print</h2><p>self-replicating TMs</p>
<p>我们能否构建一个TM $S$, s.t. $S$ will print its own description $<S>$</p>
<p><img src="/Blog/Blog/intro/cmpt308/sp.PNG" srcset="/img/loading.gif" lazyload></p>
<p>我们无法通过单个TM实现这个操作, 这类似先有鸡还是先有蛋的问题</p>
<p>例如: print(“program”)</p>
<p>要打印上面的信息我们就要 print(‘print(“program”)’)</p>
<p>就是说我们在print之前就要知道program长什么样, 但是如果不写print我们就不知道program长什么样子</p>
<br>

<p>思路:</p>
<p>明显上面 hard code 的方式是不可取的</p>
<p><img src="/Blog/Blog/intro/cmpt308/sp_1.PNG" srcset="/img/loading.gif" lazyload></p>
<p>我们有两个TM, A, B</p>
<ol>
<li>B got its own description <code>&lt;B&gt;</code> from A</li>
<li>B then <strong>reconstructs</strong> <code>&lt;A&gt;</code></li>
<li>Finally, B outputs <code>&lt;AB&gt;=&lt;S&gt;</code></li>
</ol>
<p>TM $A$ 是非常特殊的, 使得 B 可以通过 A 的 output 来 reconstruct A</p>
<p>我们定义 $q:\Sigma^\star\to \Sigma^\star$ so that</p>
<p>$\forall w \in \Sigma^\star, q(w) &#x3D; \langle P_w\rangle $</p>
<p>where TM $P_w$</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">On</span> <span class="hljs-keyword">input</span> x,<br><span class="hljs-keyword">write</span> w <span class="hljs-keyword">on</span> the output tape <span class="hljs-keyword">and</span> halt<br></code></pre></td></tr></table></figure>

<p>q is a <strong>computable function</strong></p>
<p>定义: <code>&lt;A&gt; = q(&lt;B&gt;) = &lt;P_&lt;B&gt;&gt;</code> </p>
<p>This TM $A$ will print out <code>&lt;B&gt;, &lt;A&gt;</code> can be reconstructed from the output <code>&lt;B&gt;</code> of A by computing <code>q(&lt;B&gt;)</code></p>
<p>我们依然还没有确定 B</p>
<p><img src="/Blog/Blog/intro/cmpt308/sp_1.PNG" srcset="/img/loading.gif" lazyload></p>
<p>定义TM B</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">On input z<br>compute a = <span class="hljs-string">q(z)</span><br>output a, z<br></code></pre></td></tr></table></figure>

<p>定义 TM A (<code>=q(&lt;B&gt;)</code>)</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">On</span> <span class="hljs-keyword">input</span> x, <span class="hljs-keyword">write</span> &quot;On input z, compute a = q(z), Output a,z&quot;<br><span class="hljs-keyword">On</span> the output tape <span class="hljs-keyword">and</span> halt<br></code></pre></td></tr></table></figure>

<p>这个例子中 q(z) 就是:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">&#x27;<span class="hljs-keyword">On</span> <span class="hljs-keyword">input</span> x, write <span class="hljs-string">&quot;&#x27; + z + &#x27;&quot;</span><span class="hljs-keyword">On</span> the output tape and halt&#x27;<br></code></pre></td></tr></table></figure>

<p>这里重点是什么? 重点是我们怎么得到A</p>
<p>我们没有hard code $A$, 我们 compute $A$</p>
<p>此时 TM $S &#x3D; AB$  就会 print <code>&lt;A&gt;&lt;B&gt;=&lt;S&gt;</code></p>
<br>

<p>更一般的情况, 我们可以设计TM that is “self-aware”</p>
<br>

<br>

<h2 id="Recursion-Theorem"><a href="#Recursion-Theorem" class="headerlink" title="Recursion Theorem"></a>Recursion Theorem</h2><p>For every computable function<br>$$<br>t:\Sigma^\star \times \Sigma^\star\to \Sigma^\star<br>$$<br>there is a TM $R$ s.t.</p>
<p><img src="/Blog/Blog/intro/cmpt308/recur.PNG" srcset="/img/loading.gif" lazyload></p>
<p>证明:</p>
<p><img src="/Blog/Blog/intro/cmpt308/recur_1.PNG" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p>$T$ 是 已知的</p>
</li>
<li><p>$A$ got input $w$, outputs $w, \langle BT \rangle$</p>
</li>
<li><p>$B$ got $w, \langle BT \rangle$, reconstructs $\langle A \rangle$ and outputs $\langle ABT \rangle , w$</p>
</li>
</ul>
<br>

<p><strong>根据 Recursion Theorem, 我们可以设计出可以 “get own code” 的 TMs</strong> </p>
<p>例如: <code>S=&quot;get own code &lt;S&gt;, output &lt;S&gt;&quot;</code></p>
<p>这种代码可以应用在病毒上, 让病毒实现自我复制等操作</p>
<p>同时 virus checking is undecidable</p>
<br>

<h3 id="Self-Print-is-undecidable"><a href="#Self-Print-is-undecidable" class="headerlink" title="Self-Print is undecidable"></a>Self-Print is undecidable</h3><p>$$<br>\text{Self-Print} &#x3D; (\langle M \rangle \text{ | M on } \epsilon \text{ prints} \langle M \rangle)<br>$$</p>
<p>这里我们不能使用 Rice’s Theorem, 可以回头看 Rice’s Theorem 的定义</p>
<p>Self print 和 M 的 language 无关</p>
<br>

<p>要证明 Self-Print 是 undecidable 我们会 show $A_{TM} \le \text{ Self-Print}$</p>
<p>对于给定的 $\langle M,w \rangle$我们可以构建 TM $S$</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">get</span> own description <span class="hljs-symbol">&lt;S&gt;</span><br><br>Simulate M <span class="hljs-keyword">on</span> <span class="hljs-keyword">w</span><br><br><span class="hljs-keyword">if</span> M accept <span class="hljs-keyword">w</span><br>then output <span class="hljs-symbol">&lt;S&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>M accept w $\to$ S print <code>&lt;S&gt;</code></li>
<li>M not accept w $\to$ S doesn’t print <code>&lt;S&gt;</code></li>
</ul>
<br>

<p>然而 Self-Print 是 semi-decidable 的</p>
<h3 id="Fix-Point-Theorem"><a href="#Fix-Point-Theorem" class="headerlink" title="Fix-Point Theorem"></a>Fix-Point Theorem</h3><p>For any computable function $t:\Sigma^\star \to \Sigma^\star$, there is a TM $F$ such that $\langle F \rangle, t(\langle F \rangle)$ are description of two TMs that accept exactly the same language.</p>
<br>

<p>对于所有的 computable function $t:\Sigma^\star \to \Sigma^\star$  ( 如果 t(a) &#x3D; a, a 就是 t 的 fix point )</p>
<p>there exists TM $F$ s.t.<br>$$<br>t(\langle F \rangle) &#x3D; \langle G \rangle \text{   and   } L(G) &#x3D;L(F)<br>$$<br>证明 </p>
<p>构建 F</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">on</span> <span class="hljs-built_in">input</span> <span class="hljs-keyword">w</span>,<br><span class="hljs-built_in">get</span> own description <span class="hljs-symbol">&lt;F&gt;</span><br>compute <span class="hljs-symbol">&lt;G&gt;</span> = t(<span class="hljs-symbol">&lt;F&gt;</span>)<br>Simulate G <span class="hljs-keyword">on</span> <span class="hljs-keyword">w</span><br></code></pre></td></tr></table></figure>



<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>我们可以用它来证明 $A_{TM}$ is undecidable</p>
<p>$$<br>A_{TM} &#x3D; (\langle M, w \rangle \text{ | TM M accepts w})<br>$$<br>证明:</p>
<p>Suppose $A_{TM}$ is decidable. Let $H$ be a TM decider for $A_{TM}$ Define a new TM $M$</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">input</span> <span class="hljs-keyword">x</span><br><br><span class="hljs-built_in">get</span> own code <span class="hljs-symbol">&lt;M&gt;</span><br>Simulate H(&lt;M, <span class="hljs-symbol">&lt;M&gt;</span>&gt;)<br>accept <span class="hljs-keyword">x</span> iff H reject<br></code></pre></td></tr></table></figure>

<ul>
<li>$M$ accepts <code>&lt;M&gt;</code><ul>
<li><code>H(&lt;M, &lt;M&gt;&gt;)</code> rejects</li>
<li><code>&lt;M, &lt;M&gt;&gt;</code> $\notin A_{TM}$</li>
<li>M doesn’t accept <code>&lt;M&gt;</code></li>
</ul>
</li>
</ul>
<p>contradiction!  假设错误, $A_{TM}$ is undecidable</p>
<br>

<h2 id="TM-Minimization"><a href="#TM-Minimization" class="headerlink" title="TM Minimization"></a>TM Minimization</h2><p>我们说 DTM $M$ is minimal, 如果没有 TM $M’$ exists s.t.</p>
<ol>
<li>$|\langle M’ \rangle| &lt; |\langle M \rangle|$ and</li>
<li>$L(M’)&#x3D;L(M)$</li>
</ol>
<blockquote>
<p>之前说过 DFA 的 Minimization 是可行的 (poly-time)</p>
</blockquote>
<p>那么 TM Minimization 是否可行?</p>
<p>Can we recognize if a given TM $M$ is minimal?</p>
<br>

<p>定义:<br>$$<br>MIN_{TM} &#x3D; (\langle M \rangle \text{ | M is a minimal TM})<br>$$<br>问题就是 </p>
<ul>
<li>Is $MIN_{TM}$ decidable?</li>
<li>Is $MIN_{TM}$ semi-decidable?</li>
</ul>
<br>

<h3 id="MIN-TM-是-一个-infinite-set"><a href="#MIN-TM-是-一个-infinite-set" class="headerlink" title="MIN TM 是 一个 infinite set"></a>MIN TM 是 一个 infinite set</h3><p>首先我们先证明一个结论: $MIN_{TM}$ is a infinite set</p>
<p>证明:</p>
<p>假设 $MIN_{TM}$ 是 finite, $MIN_{TM}&#x3D;(\langle M_1 \rangle\cdots \langle M_k \rangle)$ for some $k \in \N$</p>
<p>let $b&#x3D;b_1b_2\cdots b_k \in {0, 1}^k$  be s.t.</p>
<p><img src="/Blog/Blog/intro/cmpt308/min.PNG" srcset="/img/loading.gif" lazyload></p>
<p>定义 TM $A$:</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">input x<br><br>if x <span class="hljs-operator">=</span> &lt;Mi&gt; for some <span class="hljs-number">1</span>&lt;<span class="hljs-operator">=</span>i&lt;<span class="hljs-operator">=</span>k<br>then accept iff bi <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>else reject<br></code></pre></td></tr></table></figure>

<p>显然 $L(A)\ne L(M_i), \forall 1 \le i \le k$</p>
<p>让 $A’$ be a min $TM$ s.t. $L(A’)&#x3D;L(A)$ , 我们就得到 $\langle A’\rangle \ne \langle M_i \rangle, \forall 1 \le i \le k$</p>
<p>但是所有 min TMs 应该在 $MIN_{TM}$ 中, Contradiction</p>
<br>

<h3 id="MIN-TM-is-not-semi-decidable"><a href="#MIN-TM-is-not-semi-decidable" class="headerlink" title="MIN TM is not semi-decidable"></a>MIN TM is not semi-decidable</h3><p>证明:</p>
<p>假设 $MIN_{TM}$ is semi-decidable</p>
<p>let $E$ be a TM enumerator for $MIN_{TM}$</p>
<blockquote>
<p>例如: TM $E$ print out (enumerates) all and only strings <code>&lt;M&gt;</code> s.t. M is a minimal TM</p>
</blockquote>
<p>我们可以定义一个new TM $C$</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">on</span> <span class="hljs-built_in">input</span> <span class="hljs-keyword">x</span><br><br><span class="hljs-built_in">get</span> own code <span class="hljs-symbol">&lt;C&gt;</span><br><span class="hljs-keyword">let</span> n = |<span class="hljs-symbol">&lt;C&gt;</span>|<br><br>Simulate enumerator E, until E prints out some <span class="hljs-symbol">&lt;M&gt;</span> such that |<span class="hljs-symbol">&lt;M&gt;</span>| &gt; n<br><br>Then simulate that M <span class="hljs-keyword">on</span> <span class="hljs-keyword">x</span><br>accepting iff M accepts <span class="hljs-keyword">x</span><br></code></pre></td></tr></table></figure>

<p>这个TM $C$ 的language 和 $M$ 的一样</p>
<p>由于 $MIN_{TM}$ 是 infinite, 所以这一步操作会发生</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Simulate enumerator E, <span class="hljs-keyword">until</span> E prints out <span class="hljs-keyword">some</span> &lt;M&gt; such <span class="hljs-keyword">that</span> |&lt;M&gt;| &gt; n<br></code></pre></td></tr></table></figure>

<p>然而</p>
<ol>
<li><p>根据上面算法发现的 $M$ 应该是 minimal</p>
</li>
<li><p><code>|&lt;M&gt;| &gt; |&lt;C&gt;|</code></p>
</li>
<li><p>$L(C)&#x3D;L(M)$</p>
</li>
</ol>
<p>1, 2, 3 不能同时发生, 矛盾</p>
<br>

<br>

<h2 id="Kolmogorov-Complexity"><a href="#Kolmogorov-Complexity" class="headerlink" title="Kolmogorov Complexity"></a>Kolmogorov Complexity</h2><p>有一些 binary string 比其他的看起来 “更随机” (more random)</p>
<p>对比: <code>01010101010</code> <code>00101100001</code> </p>
<p>Can we define the notion of randomness for an individual binary string?</p>
<br>

<p>这个方法就是使用TM</p>
<p>思想: Describe a string $x$ by a shortest possible algorithm that would print out $x$</p>
<p>例如: <code>0101010101</code> $\iff$ M:”print <code>01</code> 5 times”</p>
<br>

<p>定义: Kolmogorov complexity of a binary string $x$ , 记作 $K(x)$<br>$$<br>K(x)&#x3D;\min(|\langle M ,w\rangle|)<br>$$<br>where TM $M$ on $w$ prints $x$</p>
<br>

<p>定义: a string $x \in {0,1}^n$ is Kolmogorov-random if $K(x) \ge n-c$, for some constant $c\ge 0$</p>
<p>Are there K-random strings?</p>
<br>

<p>Claim:</p>
<p> <img src="/Blog/Blog/intro/cmpt308/random.PNG" srcset="/img/loading.gif" lazyload></p>
<p>证明: </p>
<p><img src="/Blog/Blog/intro/cmpt308/random_1.PNG" srcset="/img/loading.gif" lazyload></p>
<p><img src="/Blog/Blog/intro/cmpt308/random_2.PNG" srcset="/img/loading.gif" lazyload></p>
<p><img src="/Blog/Blog/intro/cmpt308/random_11.PNG" srcset="/img/loading.gif" lazyload></p>
<p>string 的个数大于图灵机的个数, 所以至少存在一个K-random string</p>
<blockquote>
<p>这里 $K(x) \ge n$ 这个条件是控制 random 的数量的</p>
<p>例如我们可以让 $K(x) \ge n&#x2F;2$ 这样来增大 random string 的数量, 因为是否random本身就是一个相对的概念, 可以主观控制</p>
<p>$K(x) \ge n-\log n$ , $K(x)\ge n-c$ 等等</p>
</blockquote>
<blockquote>
<p>Can we compute the function $K(x)$ ? No, 证明放在最底下</p>
<p><img src="/Blog/Blog/intro/cmpt308/random_3.PNG" srcset="/img/loading.gif" lazyload></p>
<p>is not semi-decidable</p>
</blockquote>
<br>

<p><strong>Kolmogorov’s Message:</strong></p>
<p>Random-looking strings &#x3D; Incompressible strings</p>
<br>

<h3 id="Chaitin’s-Omega-number"><a href="#Chaitin’s-Omega-number" class="headerlink" title="Chaitin’s $\Omega$ number"></a>Chaitin’s $\Omega$ number</h3><p>我们知道 K-random string 存在, 但是是否存在有明确定义的 (explicitly defined (“natural”)) K-random strings?</p>
<br>

<p>Chaitin’s $\Omega$ number 就是, 定义:</p>
<p>$\Omega$ &#x3D; the probability that a <strong>random</strong> TM M halts(on input $\langle M \rangle$)</p>
<br>

<blockquote>
<p>amazing fact:</p>
<p>如果我们有了 $\Omega$ 的前 n 个binary digits, 那么我们就可以判断 TM $M$ ($|\langle M \rangle| \le n$) 是否 halt on input $\langle M \rangle$</p>
<br>

<p>大约有 $2^n$  $\text{length} \le n$ 个 TMs, 然而我们只需要知道 n bits of $\Omega$ 就能知道这 $2^n$ TM 是否 decidable</p>
<p>证明会在后面给出</p>
</blockquote>
<br>

<h3 id="Kolmogorov-Randomness"><a href="#Kolmogorov-Randomness" class="headerlink" title="Kolmogorov Randomness"></a>Kolmogorov Randomness</h3><p>Kolmogorov Complexity $K(x)$ of a binary string $x$ is</p>
<p><img src="/Blog/Blog/intro/cmpt308/random_4.PNG" srcset="/img/loading.gif" lazyload></p>
<p>这里 $|\langle M \rangle w|$ 是 description of x (denoted $d(x)$)</p>
<br>

<p>$|\langle M \rangle w|$ 是binary string, 问题是: 我们怎么才能 encode&#x2F;recover M,w</p>
<p>例如 :</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-symbol">&lt;M&gt;</span> = <span class="hljs-number">0101</span><br><span class="hljs-keyword">w</span> = <span class="hljs-number">10100100</span><br><br>那么<br><span class="hljs-symbol">&lt;M&gt;</span><span class="hljs-keyword">w</span> = <span class="hljs-number">010110100100</span><br>问题是对于这个 <span class="hljs-built_in">string</span> 我们怎么判断哪部分是 <span class="hljs-symbol">&lt;M&gt;</span>, 哪部分是<span class="hljs-keyword">w</span>?<br></code></pre></td></tr></table></figure>

<p>一种解决方法是Repetition code</p>
<p>$\text{Encode} (x_1\cdots x_n) &#x3D; x_1x_1 x_2x_2\cdots x_nx_n 01$</p>
<p>最后的 01 是 separator</p>
<p>还是上面的例子</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;M&gt; <span class="hljs-operator">=</span> <span class="hljs-number">0101</span><br><span class="hljs-attribute">w</span> <span class="hljs-operator">=</span> <span class="hljs-number">10100100</span><br><br>那么<br>&lt;M&gt;w <span class="hljs-operator">=</span> <span class="hljs-number">001100110110100100</span><br>       <span class="hljs-number">00110011</span> <span class="hljs-number">01</span> <span class="hljs-number">10100100</span><br>通过 separator <span class="hljs-number">01</span> 判断 &lt;M&gt; 和 w<br></code></pre></td></tr></table></figure>

<p>需要的空间: $|\text{Encode} (\langle M\rangle) w|&#x3D;2\cdot |\langle M \rangle|+2+|w|$</p>
<p>这里 $|\langle M \rangle|$ 是 常量, 而 $|w|$ 作为 input 是变量, 我们选择让常量乘2</p>
<br>

<p>然而我们可以更有效地 encoding</p>
<p>让$l_x&#x3D;|x|$ in binary</p>
<p>我们可以这样encode: $x, y\to Encode(l_x) xy$</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">x = 0101<br>y = 011101<br>l_x =<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 100 </span>in binary<br><br>所以 xy 可以编码为<br>110000<span class="hljs-number"> 01 </span>0101 011101<br><br>解析时, 先解析separator前的那部分<br>110000 -&gt;<span class="hljs-number"> 100 </span>-&gt; 4<br>说明 x 的长度为 4<br>说明 separator 后面<span class="hljs-number"> 4 </span>bit 代表 x<br>x = 0101<br>余下的是 y<br></code></pre></td></tr></table></figure>

<p>需要的空间: $2\cdot \log_2|x| + 2+|x|+|y|$</p>
<p>对于这部操作我们可以进行迭代</p>
<p>例如 我们把 $\log_2|x|$  看作时 $x’$ , $|x|+|y|$ 看作 $y’$</p>
<p>就可以重复上面操作</p>
<p>$2\log_2\log_2 |x| +2 + log_2|x| + |x|+|y|$</p>
<blockquote>
<p>一般进行一次操作空间就够小了</p>
</blockquote>
<br>

<h3 id="Basic-Properties-of-K-x"><a href="#Basic-Properties-of-K-x" class="headerlink" title="Basic Properties of $K(x)$"></a>Basic Properties of $K(x)$</h3><p><img src="/Blog/Blog/intro/cmpt308/random_5.PNG" srcset="/img/loading.gif" lazyload></p>
<p>证明: 定义 TM M “on input w, halt” $d(x)&#x3D;\langle M\rangle x$ , $|d(x)|\le c+|x|$ </p>
<p><img src="/Blog/Blog/intro/cmpt308/random_6.PNG" srcset="/img/loading.gif" lazyload></p>
<p><img src="/Blog/Blog/intro/cmpt308/random_7.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<h3 id="Incompressible-String"><a href="#Incompressible-String" class="headerlink" title="Incompressible String"></a>Incompressible String</h3><p>定义: 一个 binary string $x$ is c-compressible if<br>$$<br>K(x) \le |x|-c<br>$$<br><br></p>
<p>之前证明过当$c&#x3D;1$的情况, 对于更一般化的$c$</p>
<p>for all $c \ge 1$, for all $n$(string length), c-compressible strings 的数量 $\le$ $2^{n-c+1}-1$</p>
<p>so the fraction of <strong>non c-compressible</strong> strings of length n is<br>$$<br>\ge \frac {2^n-(2^{n-c+1}-1)}{2^n}<br>$$</p>
<p>$$<br>&#x3D;1-\frac{1}{2^{c-1}}<br>$$</p>
<p>$c$ 越大 这个值就越接近1</p>
<br>

<p>Theorem: </p>
<p><img src="/Blog/Blog/intro/cmpt308/random_8.PNG" srcset="/img/loading.gif" lazyload></p>
<p>the minimal description $d(x)$ is not b-compressible</p>
<p>证明思路: Optimally compressed string cannot be compressed any further</p>
<br>

<h3 id="Prefix-free-encoding-prefix-code"><a href="#Prefix-free-encoding-prefix-code" class="headerlink" title="Prefix-free encoding (prefix code)"></a>Prefix-free encoding (prefix code)</h3><p>$$<br>\langle M_1\rangle, \langle M_2 \rangle\cdots<br>$$</p>
<ul>
<li>每个 $\langle M_i \rangle$ 是 binary string</li>
<li>No encoding $\langle M_i \rangle$ is a prefix of some other encoding $\langle M_j \rangle, j\ne i$</li>
</ul>
<blockquote>
<p>这里和霍夫曼编码有点关系</p>
</blockquote>
<p>例如 :</p>
<p><code>0, 10, 111</code> 是 prefix free code</p>
<p>而 <code>0, 00, 01</code> 则不是 因为 <code>0</code> 是 <code>00</code> 的 prefix </p>
<br>

<p>我们如何得到一组prefix-free encoding TMs?</p>
<p>let $\langle M \rangle$ be a standard (arbitrary) encoding of $M$ in binary</p>
<p>let $Enc(x_1x_2\cdots x_n)&#x3D;x_1x_1x_2x_2\cdots x_nx_n 01$ be the repetition code</p>
<p>Encode M:<br>$$<br>\langle M \rangle_p &#x3D; \text{Enc}(l_M) \langle M \rangle<br>$$<br>where $l_M &#x3D; |\langle M \rangle|$ in binary</p>
<p>此时 $\langle M \rangle_p$ is prefix-free encoding of TMs</p>
<br>

<p>定义:<br>$$<br>\Omega &#x3D; \sum_{\langle M \rangle_p: \text{TM M halts on } \langle M \rangle_p } \frac 1 {2^{|\langle M \rangle_p|}}<br>$$<br>$0 \le \Omega \le 1$</p>
<br>

<p>例如:</p>
<p>假设 $\langle M_p \rangle \in (0, 10, 110)$ (prefix-free) halting TMs (they halt on their description)</p>
<p>then they will contribute<br>$$<br>\frac 1 {2^1} +\frac 1 {2^2}+\frac 1 {2^3}<br>$$</p>
<p>$$<br>&#x3D;(0.1)_2 + (0.01)_2 + (0.001)_2<br>$$</p>
<p>$$<br>&#x3D;(0.111) _{2} &#x3D; (0.875) _{10} &lt; 1<br>$$</p>
<br>

<p><strong>Kraft’s inequality</strong>: For any prefix-free code $C&#x3D;(c_1, c_2, c_3\cdots)$<br>$$<br>\sum_{c\in C}2^{-|c|} \le 1<br>$$<br>根据 Kraft’s inequality, 我们得到<br>$$<br>\Omega \le 1<br>$$</p>
<blockquote>
<p>其实是 $\Omega &lt; 1$, 因为有 non-halting TMs</p>
</blockquote>
<p>$\Omega$ 可以看作是 halting probability<br>$$<br>\Omega &#x3D; \sum_{\langle M \rangle_p: \text{TM M halts on } \langle M \rangle_p } \frac 1 {2^{|\langle M \rangle_p|}}<br>$$<br>$\frac 1 {2^{|\langle M \rangle_p|}}$ 可以看作是: probability of choosing $\langle M \rangle_p$ when tossing random coins</p>
<br>

<h3 id="Random-Sampling-of-TMs"><a href="#Random-Sampling-of-TMs" class="headerlink" title="Random Sampling of TMs"></a>Random Sampling of TMs</h3><p>Choose uniformly random, independent bits<br>$$<br>b_1b_2b_3\cdots b_i\cdots<br>$$<br>until the first time $i$ s.t. $b_1b_2\cdots b_i&#x3D;\langle M \rangle_p$ for some TM $M$ output $\langle M \rangle_p$  (${2^{-|\langle M \rangle_p|}}$)</p>
<br>

<p>所以 $\Omega &#x3D; $ Probability of choosing a halting TM</p>
 <br>

<h3 id="Digits-of-Omega"><a href="#Digits-of-Omega" class="headerlink" title="Digits of $\Omega$"></a>Digits of $\Omega$</h3><p>$$<br>\frac 12 &#x3D; (0.1)_2<br>$$</p>
<p>$$<br>\frac 12 &#x3D; (0.011111\cdots)_2<br>$$</p>
<p>我们应该用哪个sequence?</p>
<p>显然用短的那个</p>
<br>

<p>Compute $\Omega$ in stages<br>$$<br>\Omega_k &#x3D; \sum_{\text{TM M:} |\langle M\rangle _p| \le k \text{ and M halts on}  \langle M \rangle_p \text{ with k steps}} \frac 1 {2^{|\langle M \rangle_p|}}<br>$$<br><img src="/Blog/Blog/intro/cmpt308/random_9.PNG" srcset="/img/loading.gif" lazyload></p>
<p>write each $\Omega_k$ in binary:<br>$$<br>\Omega_k &#x3D; 0.w_1w_2\cdots w_l<br>$$<br>这个迭代是收敛的, 当迭代到一定程度后 $\Omega_k$ 的前 $N$ 个digits 就不会再变动了, 此时  $\Omega_k$ 的前 $N$ 个digits 等于  $\Omega$ 的前 $N$ 个digits </p>
<p>$\forall N\ge 1, \exists k\ge 1$ the first $N$ digits of $\Omega_k$ will stay as the first N digits of every $\Omega_{k’}$ for all $k’\ge k$</p>
<br>

<p>之前也说过, 如果我们得到 $\Omega$ 的前N个digits, 我们就能判断长度为 $N$ 的 TM 的halting problem</p>
<p>证明:</p>
<p>For any given TM $A$, s.t. $|\langle A \rangle| \le N$ run the following algorithm to decide if A halts on $\langle A \rangle_p$</p>
<p>Compute $\Omega_1\Omega_2,\cdots$ until get $\Omega_k$ s.t. the first $N$ digits of $\Omega_k&#x3D;$ those of $\Omega$ , accept iff TM A halts on $\langle A \rangle_p$</p>
<br>

<p>正确性: </p>
<p>这个算法总是 terminates at stage $k$</p>
<p>如果 TM A hasn’t halted on $\langle A \rangle_p$ within k steps, A doesn’t halt at all</p>
<p>Indeed, suppose $A$ halts on $\langle A \rangle_p$ within $t\ge k$ steps then<br>$$<br>\Omega_t\ge  \Omega_k+ \frac 1 {2^{|\langle A\rangle_p|}}<br>$$<br>由于<br>$$<br>\frac 1 {2^{|\langle A\rangle_p|}}\ge \frac 1 {2^N}<br>$$<br>所以<br>$$<br>\Omega_t\ge  \Omega_k+ \frac 1 {2^N}<br>$$</p>
<p><img src="/Blog/Blog/intro/cmpt308/random_10.PNG" srcset="/img/loading.gif" lazyload></p>
<p>然而这会导致 first $N$ digits of $\Omega_k$ changes! 我们知道前N个digits不会变, 所以矛盾</p>
<br>

<p>Theorem: Let $\Omega&#x3D;0.w_1w_2w_3\cdots$</p>
<p>there exists $b &gt; 0$</p>
<p>for all $N\in \N$<br>$$<br>K(w_1w_2w_3\cdots w_N)\ge N-b<br>$$<br>That is, the first $N$ bits of $\Omega$ is <strong>not</strong> a b-compressible string</p>
<p>证明:</p>
<p>假设: $K(w_1w_2w_3\cdots w_N)&lt; N-b$ for all $b$</p>
<p>step 1:</p>
<p>By the earlier claim,get TM $H$ of $|\langle H\rangle_p| &lt; N-b$ for all $b$, s.t. TM $H$ decides the Halting problem for all TMs M s.t. $|\langle M \rangle_p|\le N$</p>
<p>step 2:</p>
<p>By a diagonalization argument, show there exists constant $c\ge 0$ s.t.</p>
<p>​    every TM $D$ that decides the halting problem for all TMs $M$ s.t. $|\langle M\rangle _p|\le N$ must have size<br>$$<br>|\langle D\rangle_p |\ge N-c<br>$$<br>但是TM $H$ has $|\langle H\rangle_p|\le N-b$ for all b, and so $|\langle H\rangle_p|&lt; N-c$</p>
<p>contradiction</p>
<br>

<br>

<blockquote>
<p>$\Omega$ 的注意事项</p>
<ol>
<li>$\Omega$ is <strong>not a fixed</strong> real number, but rather it depends on a particular prefix-free encoding of TMs (不同的encoding有不同的$\Omega$)</li>
<li>$\Omega$ is not computable: There is no TM $C$ s.t. given $i$ $C(i)$ prints the $i^\text{th}$ bit of $\Omega$</li>
<li>$\Omega$ is an <strong>optimal compression</strong> of the Halting problem</li>
</ol>
</blockquote>
<br>

<br>

<h2 id="Godel’s-Incompleteness"><a href="#Godel’s-Incompleteness" class="headerlink" title="Godel’s Incompleteness"></a>Godel’s Incompleteness</h2><p>17 世纪的  philosophy</p>
<table>
<thead>
<tr>
<th>Math</th>
<th>Physics</th>
</tr>
</thead>
<tbody><tr>
<td>所有的知识都可以通过理性获得 (All knowledge can be gained by reason alone)</td>
<td>所有的知识都必须来自通过感官的经验 (All knowledge has to come from experience through senses)</td>
</tr>
</tbody></table>
<p>19世纪早期到20世纪</p>
<p>foundations of Math</p>
<p>D. Hilbert asked for Axiomatization of Mathematics</p>
<p>1930’s Kurt Godel proved that arithmetic cannot be axiomatized</p>
<blockquote>
<p>informally, there is no <strong>finite set of axioms and derivation rules</strong></p>
<p>so that every true arithmetic formula can be derived</p>
</blockquote>
<blockquote>
<p>there are true arithmetic sentences whose truth cannot be proved</p>
</blockquote>
<p>这里有三个概念是不清晰的:</p>
<p>arithmetic sentence ?</p>
<p>truth ?</p>
<p>provable ?</p>
<br>

<p>arithmetic formulas are formed using:</p>
<p><img src="/Blog/Blog/intro/cmpt308/formula.PNG" srcset="/img/loading.gif" lazyload></p>
<p>例如:</p>
<p><img src="/Blog/Blog/intro/cmpt308/formula_1.PNG" srcset="/img/loading.gif" lazyload><br>$$<br>f(x)&#x3D;\exists y [x&#x3D;2\times y]<br>$$<br>这里 x 是一个free variable</p>
<br>

<p>定义:  a sentence is a formula with <strong>no</strong> free variables</p>
<p>Truth: each sentence is either true or false over $\N$, with <strong>standard interpretation</strong> of all arithmetic symbols</p>
<blockquote>
<p>standard model of arithmetic</p>
<p>因为我们其实可以对运算符进行重新定义, 例如我们定义 $1+1&#x3D;1^1$</p>
<p>而 standard 就是说 $1+1&#x3D;2$, 没有特殊的定义, 0就代表0</p>
</blockquote>
<p><strong>Provable:</strong> </p>
<p>a proof system consists of </p>
<ul>
<li>a finite set of axioms (truths)</li>
<li>a finite set of inference rules</li>
</ul>
<br>

<p>a proof system to reason about properties of natural numbers is <strong>Peano arithmetic (PA)</strong></p>
<p>nonlogical symbols: 0, S (successor operator), $+, \times, &#x3D;, \le$ </p>
<br>

<p>axioms for the properties of $0, S,+, \times &#x3D;, \le$</p>
<p><img src="/Blog/Blog/intro/cmpt308/formula_2.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<p>Induction Schema for each FO formula $\phi$</p>
<p><img src="/Blog/Blog/intro/cmpt308/formula_3.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<p>Inference Rules: Classical Logic</p>
<p><img src="/Blog/Blog/intro/cmpt308/formula_4.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<p>定义: a proof of a formula $\phi$ is sequence $A_1, A_2,\cdots A_t&#x3D;\phi$ where $A_i$ is either an axiom or follows from some previous formulas using some inference rule.</p>
<br>

<br>

<p><strong>Empirical Fact</strong></p>
<p>every standard <strong>proof system</strong> is such that there is an <strong>efficient procedure (algorithm)</strong> to <strong>check if</strong> a given <strong>sequence of formulas</strong> is <strong>valid</strong> proof.</p>
<blockquote>
<p>This is where logic connects with computability: <strong>Logical reasoning is very algorithmic in nature.</strong></p>
</blockquote>
<br>

<h3 id="Sound"><a href="#Sound" class="headerlink" title="Sound"></a>Sound</h3><p>定义: a proof system is <strong>sound</strong> if everything it proves is actually true. (就是说这个system不会说谎, 它说是true, 就一定是true, 不可能是false)</p>
<p>显然我们希望有一个 sound proof system</p>
<br>

<h3 id="Complete"><a href="#Complete" class="headerlink" title="Complete"></a>Complete</h3><p>定义: a proof system is <strong>complete</strong> if every true statement is provable in the system </p>
<p>简单来说就是这个system knows every thing</p>
<br>

<h3 id="Godel’s-1st-incompleteness-theorem"><a href="#Godel’s-1st-incompleteness-theorem" class="headerlink" title="Godel’s 1st incompleteness theorem"></a>Godel’s 1st incompleteness theorem</h3><p>Fix any proof system $P$ containing PA(arithmetic) if $P$ is <strong>sound</strong> , then $P$ is <strong>NOT complete</strong></p>
<p>sound 和 complete 不能同时存在</p>
<br>

<p>证明:</p>
<p><img src="/Blog/Blog/intro/cmpt308/incomplete.PNG" srcset="/img/loading.gif" lazyload></p>
<p>思路: Since $\varphi$ is sound, <img src="/Blog/Blog/intro/cmpt308/sube.PNG" srcset="/img/loading.gif" lazyload></p>
<p>我们要证明 there exists <strong>true but NOT provable</strong> statements about natural numbers</p>
<br>

<p>Claim 1: <strong>Provable</strong> is semi-decidable</p>
<p>证明: 可以设计这样一个图灵机</p>
<p>Given $\langle \varphi\rangle $, try all strings (in lexicographic order), and check if any of them is valid proof of $\varphi$. If a valid proof is found then Accept</p>
<br>

<p>Claim 2: <strong>True</strong> is not semi-decidable</p>
<p>这个不好证明, 这里只讲述一个思路</p>
<br>

<blockquote>
<p>godel’s lemma (implicit):</p>
<p>for all TM $M$, for all input $w$</p>
<p>there exists arithmetic sentence $\phi_{M,w}$ s.t.<br>$$<br>\text{M accepts w} \iff \phi_{M,w} \text{ is true}<br>$$<br>moreover, $\phi_{M,w}$ is <strong>computable</strong> from $M, w$</p>
<p>就是说 arithmetic formulas can “simulate” Turing Machines</p>
</blockquote>
<br>

<p>我们通过 reduce<br>$$<br>\overline A_{TM} \le \text{True}<br>$$<br>来证明, 这等价于</p>
<p><img src="/Blog/Blog/intro/cmpt308/incomplete_1.PNG" srcset="/img/loading.gif" lazyload></p>
<br>

<br>

<h3 id="Main-idea-of-the-proof-of-Grodel’s-Lemma"><a href="#Main-idea-of-the-proof-of-Grodel’s-Lemma" class="headerlink" title="Main idea of the proof of Grodel’s Lemma"></a>Main idea of the proof of Grodel’s Lemma</h3><p>TM $M$ accepts w $\iff$ </p>
<p>there exists $c_0, c_1,\cdots c_t$ s.t.</p>
<ul>
<li>$c_0$ &#x3D; initial configuration</li>
<li>$c_t$ &#x3D; accepting configuration</li>
<li>for all $0\le i &lt; t$, $c_i \to^\delta c_{i+1}$</li>
</ul>
<blockquote>
<p>之前说过图灵机的运行可以看作是一系列configuration</p>
</blockquote>
<p>就是说初始状态是true, 结束状态是true, 每一步的transaction是true</p>
<p>然而我们不知道 $t$</p>
<p>Can’t use unbounded number of variables for configurations $c_0,c_1,c_2\cdots c_t$ </p>
<p>Code up every configuration as a number (via an appropriate encoding)</p>
<br>

<p>Chinese remainder theorem:</p>
<p>code up an arbitrary long sequence of numbers with just two numbers</p>
<p>$\forall a_1,a_2\cdots a_m \in N$</p>
<p>$\exists A,B \in N$ s.t.<br>$$<br>\beta (A, B, i)&#x3D;a_i, \forall 1 \le i\le m<br>$$<br>where<br>$$<br>\beta(x, y, i)&#x3D;{x \mod (1+y(i+1))}<br>$$</p>
<blockquote>
<p><img src="/Blog/Blog/intro/cmpt308/incomplete_2.PNG" srcset="/img/loading.gif" lazyload></p>
<p><img src="/Blog/Blog/intro/cmpt308/incomplete_3.PNG" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<br>

<br>

<br>

<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="K-x-is-not-computable"><a href="#K-x-is-not-computable" class="headerlink" title="K(x) is not computable"></a>K(x) is not computable</h2><p>假设 K(x) 是 computable, 那么就有一个TM $M_k$, 对于input $x$ 可以output $K(x)$ </p>
<p>K(x) 的定义是指: 最小的可以打印x的TM的大小</p>
<p>因此我们可以构建一个更小的TM, M’</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs llvm">get own code &lt;M&#x27;&gt;<br><br>for <span class="hljs-keyword">x</span> in &#123;<span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span>&#125;*<br>	run Mk on <span class="hljs-keyword">x</span> get K(<span class="hljs-keyword">x</span>)<br>	if K(<span class="hljs-keyword">x</span>) &gt; |&lt;M&#x27;&gt;|<br>		print <span class="hljs-keyword">x</span><br>		halt<br></code></pre></td></tr></table></figure>

<p>$M’$ 一定会halt, 因为 长度小于$|\langle M’\rangle|$ 的string 是有限的</p>
<p>$M’$ 打印 $x$, 因此 $K(x)\le |\langle M’\rangle|$ (根据K(x)的定义)</p>
<p>然而当我们知道 $K(x)&gt;|\langle M’ \rangle|$ (代码第五行)</p>
<p>矛盾, 所以 K(x) is not computable</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/09/09/Computability-and-Complexity2/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Computability and Complexity (2)</span>
                        <span class="visible-mobile">Antaŭa afiŝo</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/26/Networking/">
                        <span class="hidden-mobile">计算机网络</span>
                        <span class="visible-mobile">Sekva afiŝo</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Enhavtabelo</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Serĉi</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">ŝlosivorto</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
